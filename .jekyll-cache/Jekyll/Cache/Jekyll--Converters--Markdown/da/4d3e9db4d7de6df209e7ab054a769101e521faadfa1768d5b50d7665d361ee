I"}!<h1 id="内存使用统计">内存使用统计</h1>

<h2 id="info-中常见属性说明">info 中常见属性说明</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">属性名</th>
      <th style="text-align: center">属性说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">used_memory</td>
      <td style="text-align: center">Redis 分配器分配的内存总量(单位字节), 包含 swap</td>
    </tr>
    <tr>
      <td style="text-align: center">used_memory_human</td>
      <td style="text-align: center">以可读方式返回 used_memory</td>
    </tr>
    <tr>
      <td style="text-align: center">used_memory_rss</td>
      <td style="text-align: center">Redis 进程占操作系统的内存总量(单位字节),  跟top 或 ps 看到的一致</td>
    </tr>
    <tr>
      <td style="text-align: center">used_memory_peak</td>
      <td style="text-align: center">内存使用的最大值, 即 used_memory 的峰值</td>
    </tr>
    <tr>
      <td style="text-align: center">used_memory_peak_human</td>
      <td style="text-align: center">以可读方式返回used_memory_peak</td>
    </tr>
    <tr>
      <td style="text-align: center">used_memory_lua</td>
      <td style="text-align: center">Lua 引擎所消耗的内存大小</td>
    </tr>
    <tr>
      <td style="text-align: center">mem_fragmentation_ratio</td>
      <td style="text-align: center">used_memory_rss / used_memory 比值, 表示内存碎片率</td>
    </tr>
    <tr>
      <td style="text-align: center">mem_allocator</td>
      <td style="text-align: center">Redis 所使用的内存分配器, 默认为 jemalloc</td>
    </tr>
  </tbody>
</table>

<h2 id="属性说明补充">属性说明补充</h2>

<ol>
  <li>used_memory 是 redis 使用的实际使用的内存总量, 因此被内存碎片浪费掉的内存不包含在内</li>
  <li>mem_fragmentation_ratio一般大于 1, 业界内认为一般在 1.03 左右是健康水平.</li>
  <li>mem_fragmentation_ratio 的值越大, 内存碎片的比例越大</li>
  <li>mem_fragmentation_ratio &lt; 1 时候, 一般是使用了 swap 导致的</li>
  <li>当 redis 无数据时候或数据很少时候, used_memory_rss 比 used_memory 大很多, 碎片率暂无参考价值</li>
</ol>

<h1 id="内存消耗划分">内存消耗划分</h1>

<h2 id="实际占用内存组成">实际占用内存组成</h2>

<ol>
  <li>redis 自身进程内存</li>
  <li>对象内存</li>
  <li>缓冲内存</li>
  <li>内存碎片</li>
  <li>子进程内存消耗</li>
</ol>

<h2 id="redis-自身进程内存">redis 自身进程内存</h2>

<ol>
  <li>空 redis 进程自身消耗的内存
    <ol>
      <li>docker 容器版本, used_memory_rss一般为 9MB 左右</li>
      <li>进程版本, used_memory_rss 一般为为3MB 左右</li>
    </ol>
  </li>
  <li>故, Redis 自身进程内存可以忽略不计</li>
  <li>由于不是 jemalloc 分配的内存, 因此不会统计在 used_memory 中</li>
</ol>

<p>## 对象内存</p>

<p>用户数据再 redis 内占用的内存</p>

<ol>
  <li>由于是 k-v 结构, 故每个键值对的内存消耗为: sizeof(k) + sizeof(v)</li>
  <li>键为字符串, 建议避免使用过长的键</li>
  <li>值为字符串, 列表, 哈希, 集合, 有序集合这五种, 其中 Bitmaps 和 HyperLog 使用字符串实现, GEO 使用有序集合实现</li>
</ol>

<h2 id="缓冲内存">缓冲内存</h2>

<p>主要包含: <strong>客户端缓冲</strong>, <strong>复制积压缓冲区</strong>,  <strong>AOF 缓冲区</strong>. 该部分内存由 jemalloc 分配, 因此会包含在 used_memory 中</p>

<h3 id="客户端缓冲">客户端缓冲</h3>

<p>主要包含普通客户端, 从客户端, 订阅客户端. 所有接入到 Redis 服务器 TCP 连接的输入输出缓冲, 因此有时候也被称为输入输出缓冲区</p>

<ol>
  <li>输入缓冲无法控制, 最大为 1G</li>
  <li>输出缓冲通过参数 client-output-buffer-limit 控制, 默认值如下</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>client-output-buffer-limit normal 0 0 0
client-output-buffer-limit replica 256mb 64mb 60
client-output-buffer-limit pubsub 32mb 8mb 60
</code></pre></div></div>

<ol>
  <li>普通客户端主要指除了复制和订阅的客户端之外的所有连接. 默认未做限制, 因为普通客户端的内存消耗可以忽略不计. 但是当有大量慢连接客户端时候, 消耗就很大, 例如客户端执行 monitor 之类的需要输出大量数据时候, 很容易造成 redis 服务器的内存突然飙升. 一般会调整 maxclients 来限制</li>
  <li>从客户端主要用于主从复制, 主节点会单独建立一条连接用于命令复制. 当主从延迟很高或者挂载过多的从节点时候, 会导致该部分占用很大. 因此推荐主从不跨异地, 从节点不多于 2 个</li>
  <li>订阅客户端主要用于发布订阅功能, 该功能会使用单独的输出缓冲区. 当生产消息快于消费速度时候, 输出缓冲区的积压会造成缓冲区空间的益处.</li>
  <li>输入输出缓冲区在大流量的情况下, 容易失控, 推荐做一定的监控.</li>
</ol>

<h3 id="复制积压缓冲区">复制积压缓冲区</h3>

<p>该缓冲区是在 2.8 版本以后提供的恶一个可重用的固定大小的缓冲区, 用于实现部分复制功能, 默认值如下:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>repl-backlog-size 1mb
</code></pre></div></div>

<p>所用的从节点会共用才缓冲区, 因此可以适当调大, 一般会推荐 <code class="language-plaintext highlighter-rouge">100MB</code>的样子, 可以避免全量复制的情况</p>

<h3 id="aof-缓冲区">AOF 缓冲区</h3>

<p>该部分空间用于 redis 重写期间, 保存最近写入的命令. 该部分无法控制, 消耗的内存取决于 AOF 重写时间和写入的命令量, 大部分情况下占用都很小.</p>

<h2 id="内存碎片">内存碎片</h2>

<p>默认采用的是 jemalloc 的分配器, 编译时可选 glibc, tcmalloc 的分配器. jemalloc 一般讲系统内存划分为小, 大, 巨大三个范围. 每个范围又划分更多更小的内存单位, 如下所示:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>小   [8byte] [16byte] [32byte] [64byte] ...
大   [4KB] [8KB] [12KB] [16KB] ...
巨大 [4MB] [8MB] [12MB] [16MB] ...
</code></pre></div></div>

<p>当需要保存 5KB 的对象时候, jemalloc 可能会采用 8KB 的块存储, 而剩下的 3KB 空间就变为内存碎片不能再分配给其他对象存储, 由此产生了内存碎片. <strong>此时的 5KB 被纳入到 used_memory 的统计范围内, 操作系统上表现为 redis 消耗了 8KB 的内存.</strong></p>

<h3 id="高碎片率的原因">高碎片率的原因</h3>

<ol>
  <li>针对已存在的 key 频繁执行更新操作</li>
  <li>大量过期键删除, 释放的空间未能得到使用</li>
  <li>存储的数据长短差异较大</li>
</ol>

<h3 id="高碎片率解决版本">高碎片率解决版本</h3>

<ol>
  <li>数据对齐, 尽量使用数字类型或者固定长度的字符串</li>
  <li>安全重启, 主从切换安全重启</li>
  <li>redis4 以上设置 <code class="language-plaintext highlighter-rouge">config set activedefrag yes</code> 来保证自动清理</li>
  <li>redis4 以上可以手动执行<code class="language-plaintext highlighter-rouge">memory purge</code> 来清理内存碎片</li>
</ol>

<h2 id="子进程内存消耗">子进程内存消耗</h2>

<p>子进程内存消耗多指的是 AOF/RDB 过程创建的子进程所带来的内存消耗. 由于 linux 存在 copy-on-write 的机制, 因此父子进程会共享相同的物理内存页, 因而不需要 2 倍的物理内存来完成重写.</p>

<h1 id="内存管理">内存管理</h1>

<p>redis 中使用 maxmemory 的参数控制最大可用内存. 主要目的如下:</p>

<ol>
  <li>当内存超出 maxmemory 时候, 可以使用 LRU 等策略释放空间</li>
  <li>避免超过服务器物理内存</li>
</ol>

<h2 id="前方雷点请注意">前方雷点请注意</h2>

<ol>
  <li>maxmemory 控制的是 redis 实际使用的内存量, 也就是 used_memory 统计项对应的内存</li>
  <li>由于被浪费的内存未被纳入到 used_memory 的统计内, 因此实际消耗的内存会比 maxmemory 设置的还要大, 真实消耗的内存可粗略估计为 maxmemory * mem_fragmentation_ratio</li>
</ol>
:ET