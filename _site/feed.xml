<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-Hans"><generator uri="https://jekyllrb.com/" version="4.1.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="zh-Hans" /><updated>2020-09-07T14:01:26+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Chaim Blog</title><subtitle>Your Site Description
</subtitle><author><name>Chaim</name></author><entry><title type="html">kubernates 必知必会</title><link href="http://localhost:4000/2020/09/06/kubernates-%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A.html" rel="alternate" type="text/html" title="kubernates 必知必会" /><published>2020-09-06T00:00:00+08:00</published><updated>2020-09-06T00:00:00+08:00</updated><id>http://localhost:4000/2020/09/06/kubernates%20%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A</id><content type="html" xml:base="http://localhost:4000/2020/09/06/kubernates-%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A.html">&lt;h2 id=&quot;问题&quot;&gt;问题&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;kubernates 是什么？&lt;/li&gt;
  &lt;li&gt;kubernates 解决了什么问题？&lt;/li&gt;
  &lt;li&gt;kubernates 该如何使用？&lt;/li&gt;
  &lt;li&gt;集群中资源是如何调度的？&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;k8s-是什么-解决了什么问题&quot;&gt;k8s 是什么, 解决了什么问题&lt;/h2&gt;

&lt;p&gt;kubernates 是 Google 公司开源的一个容器编排与调度管理框架, 当前由 CNCF 托管.&lt;/p&gt;

&lt;p&gt;解决了分布式系统情况下, 容器的编排与调度问题.&lt;/p&gt;

&lt;h3 id=&quot;发展历史&quot;&gt;发展历史&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;2003-2004 年, Google 发布 Borg 系统, 3-4 人开发.  主要用于管理长时间运行的生产服务和批处理服务. Brog 将上述两种服务所需要的的机器统一成一个池子, 以便提高资源利用率, 同时降低成本. 之所以能够实现跨机器的资源共享以及进程隔离, 是因为可以拿到 Linux 内核的容器支持.``&lt;/li&gt;
  &lt;li&gt;… 年, 越来越多的应用被开发并运行在 Borg上, Google 团队开发了一个工具系统. 工具系统提供配合和更新 job 的机制, 可以预测资源需求, 动态的推送配置文件, 服务发现, 负载均衡, 自动扩容, 机器的生命周期管理, 额度管理等等. 由于要适配不同团队的需求, Borg 发展成了 ad-hoc 系统(即席查询, 用户根据自己的需求，灵活的选择查询条件，系统能够根据用户的选择生成相应的统计报表)集合, Borg 使用者可以使用不同的配置语言和进程来配置与沟通.&lt;/li&gt;
  &lt;li&gt;2006-2007 年, Paul Menage和Rohit Seth 提出了 cgroups, 并且被合并到2.6.24版的内核中&lt;/li&gt;
  &lt;li&gt;2013 年左右, 处于提升 Borg 生态系统软件工程的愿景, Google 发布了 Omega 集群管理系统. Omega 把很多 Borg 内已经被认证的成功的模式搬过来, 同时从头开始搭建一个更加一致性的构架. 添加了控制面板, 调度器等等, 以此来优化偶尔发生的资源冲突问题.  同年, docker 正式出道.&lt;/li&gt;
  &lt;li&gt;2014 年左右, Google 发布了 kubernates. 同年, Microsoft, Red Hat, IBM, Docker 等加入 kubernates 社区&lt;/li&gt;
  &lt;li&gt;2015 年, 成立了 CNCF 基金会, 托管 kubernates&lt;/li&gt;
  &lt;li&gt;2016 年左右, kubernates 成为主流. 在 CloudNative 2016 大会上, 来自全世界的贡献值和开发者一起交流kubernates, Fluentd, Promethues等云原生技术(采用开源堆栈 K8S+Docker 进行容器化，基于微服务架构提高灵活性和可维护性，借助敏捷方法、DevOps支持持续迭代和运维自动化，利用云平台设施实现弹性伸缩、动态调度、优化资源利用率)&lt;/li&gt;
  &lt;li&gt;2017 年左右, 各大互联网厂商开始纷纷支持 kubernates. 同年, istio 正式出道. Docker 容器大战正式结束, 成功上位, 作为 kubernates 容器运行时的标配.&lt;/li&gt;
  &lt;li&gt;2018 年左右, 无人不知 kubernates. 国内不论大小厂商开始进行云原生落地.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;borgomegak8s关联&quot;&gt;Borg/Omega/K8S关联&lt;/h3&gt;

&lt;p&gt;参见: &lt;a href=&quot;https://queue.acm.org/detail.cfm?id=2898444&quot;&gt;Borg/Omega/K8S关联&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;k8s特点&quot;&gt;k8s特点&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;可移植性: 支持公有云, 私有云, 混合云, 多重云&lt;/li&gt;
  &lt;li&gt;可扩展性: 模块化, 插件化, 可挂载, 可组合&lt;/li&gt;
  &lt;li&gt;自动化: 自动部署, 自动重启, 自动复制, 自动伸缩/扩展&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;k8s-该如何使用&quot;&gt;k8s 该如何使用&lt;/h2&gt;

&lt;h3 id=&quot;环境准备篇&quot;&gt;环境准备篇&lt;/h3&gt;

&lt;h4 id=&quot;本地开发环境&quot;&gt;本地开发环境&lt;/h4&gt;
&lt;p&gt;参见: &lt;a href=&quot;https://github.com/chaimch/k8s-for-docker-desktop&quot;&gt;本地开发环境&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;云羊毛环境&quot;&gt;云羊毛环境&lt;/h4&gt;
&lt;p&gt;参见一: &lt;a href=&quot;https://console.cloud.google.com/freetrial&quot;&gt;GCP 羊毛&lt;/a&gt;
参见二: &lt;a href=&quot;https://katacoda.com/learn&quot;&gt;katacoda 羊毛&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;入门&quot;&gt;入门&lt;/h3&gt;

&lt;h4 id=&quot;自动补全提示&quot;&gt;自动补全提示&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;安装 bash-completion &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yum install bash-completion&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;设置 kubectl 的别称 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;alias k=kubectl&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;bash 环境下, 调整别称 k 的自动补全 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;source &amp;lt;(kubectl completion bash | sed s/kubectl/k/g)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;zsh 环境下, 调整 k 的自动补全 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;source &amp;lt;(kubectl completion zsh)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;设置切换名称空间别称 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;alias kcd='k config set-context $(k config current-context) --namespace'&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;kubernates-官方&quot;&gt;Kubernates 官方&lt;/h4&gt;
&lt;p&gt;参见: &lt;a href=&quot;https://kubernetes.io/docs/tutorials/kubernetes-basics/&quot;&gt;Kubernates Tutorials&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;架构图&quot;&gt;架构图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/chaimch/FigureBed@master/uPic/architecture.png&quot; alt=&quot;architecture&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;组件功能&quot;&gt;组件功能&lt;/h3&gt;

&lt;h4 id=&quot;kubectl&quot;&gt;kubectl&lt;/h4&gt;
&lt;p&gt;官方提供的 CLI, 可以以交互式对 Kubernates API Server 进行操作. kubectl 发送相应的 http 请求, 由 Kubernates API Server 处理后返回并展示出结果.&lt;/p&gt;</content><author><name>Chaim</name></author><category term="kubernates" /><summary type="html">问题 kubernates 是什么？ kubernates 解决了什么问题？ kubernates 该如何使用？ 集群中资源是如何调度的？ k8s 是什么, 解决了什么问题 kubernates 是 Google 公司开源的一个容器编排与调度管理框架, 当前由 CNCF 托管. 解决了分布式系统情况下, 容器的编排与调度问题. 发展历史 2003-2004 年, Google 发布 Borg 系统, 3-4 人开发. 主要用于管理长时间运行的生产服务和批处理服务. Brog 将上述两种服务所需要的的机器统一成一个池子, 以便提高资源利用率, 同时降低成本. 之所以能够实现跨机器的资源共享以及进程隔离, 是因为可以拿到 Linux 内核的容器支持.`` … 年, 越来越多的应用被开发并运行在 Borg上, Google 团队开发了一个工具系统. 工具系统提供配合和更新 job 的机制, 可以预测资源需求, 动态的推送配置文件, 服务发现, 负载均衡, 自动扩容, 机器的生命周期管理, 额度管理等等. 由于要适配不同团队的需求, Borg 发展成了 ad-hoc 系统(即席查询, 用户根据自己的需求，灵活的选择查询条件，系统能够根据用户的选择生成相应的统计报表)集合, Borg 使用者可以使用不同的配置语言和进程来配置与沟通. 2006-2007 年, Paul Menage和Rohit Seth 提出了 cgroups, 并且被合并到2.6.24版的内核中 2013 年左右, 处于提升 Borg 生态系统软件工程的愿景, Google 发布了 Omega 集群管理系统. Omega 把很多 Borg 内已经被认证的成功的模式搬过来, 同时从头开始搭建一个更加一致性的构架. 添加了控制面板, 调度器等等, 以此来优化偶尔发生的资源冲突问题. 同年, docker 正式出道. 2014 年左右, Google 发布了 kubernates. 同年, Microsoft, Red Hat, IBM, Docker 等加入 kubernates 社区 2015 年, 成立了 CNCF 基金会, 托管 kubernates 2016 年左右, kubernates 成为主流. 在 CloudNative 2016 大会上, 来自全世界的贡献值和开发者一起交流kubernates, Fluentd, Promethues等云原生技术(采用开源堆栈 K8S+Docker 进行容器化，基于微服务架构提高灵活性和可维护性，借助敏捷方法、DevOps支持持续迭代和运维自动化，利用云平台设施实现弹性伸缩、动态调度、优化资源利用率) 2017 年左右, 各大互联网厂商开始纷纷支持 kubernates. 同年, istio 正式出道. Docker 容器大战正式结束, 成功上位, 作为 kubernates 容器运行时的标配. 2018 年左右, 无人不知 kubernates. 国内不论大小厂商开始进行云原生落地. Borg/Omega/K8S关联 参见: Borg/Omega/K8S关联 k8s特点 可移植性: 支持公有云, 私有云, 混合云, 多重云 可扩展性: 模块化, 插件化, 可挂载, 可组合 自动化: 自动部署, 自动重启, 自动复制, 自动伸缩/扩展 k8s 该如何使用 环境准备篇 本地开发环境 参见: 本地开发环境 云羊毛环境 参见一: GCP 羊毛 参见二: katacoda 羊毛 入门 自动补全提示 安装 bash-completion yum install bash-completion 设置 kubectl 的别称 alias k=kubectl bash 环境下, 调整别称 k 的自动补全 source &amp;lt;(kubectl completion bash | sed s/kubectl/k/g) zsh 环境下, 调整 k 的自动补全 source &amp;lt;(kubectl completion zsh) 设置切换名称空间别称 alias kcd='k config set-context $(k config current-context) --namespace' Kubernates 官方 参见: Kubernates Tutorials 架构图 组件功能 kubectl 官方提供的 CLI, 可以以交互式对 Kubernates API Server 进行操作. kubectl 发送相应的 http 请求, 由 Kubernates API Server 处理后返回并展示出结果.</summary></entry><entry><title type="html">AWS RDS 故障恢复</title><link href="http://localhost:4000/2020/08/12/AWS-RDS-%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D.html" rel="alternate" type="text/html" title="AWS RDS 故障恢复" /><published>2020-08-12T00:00:00+08:00</published><updated>2020-08-12T00:00:00+08:00</updated><id>http://localhost:4000/2020/08/12/AWS%20RDS%20%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D</id><content type="html" xml:base="http://localhost:4000/2020/08/12/AWS-RDS-%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D.html">&lt;h2 id=&quot;故障原因&quot;&gt;故障原因&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;可用区中断&lt;/li&gt;
  &lt;li&gt;主数据库实例故障&lt;/li&gt;
  &lt;li&gt;更改数据库实例服务器类型&lt;/li&gt;
  &lt;li&gt;数据库实例的操作系统在进行软件修补&lt;/li&gt;
  &lt;li&gt;数据库实例的手动故障转移是使用 &lt;strong&gt;Reboot with failover&lt;/strong&gt; 启动的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;amazon-rds-单可用区故障恢复&quot;&gt;Amazon RDS 单可用区故障恢复&lt;/h2&gt;

&lt;p&gt;无论是主数据库实例故障, 还是从数据库实例故障, 此时均为 EC2 启动并替换的时间, 一般需要 &lt;strong&gt;5-10 分钟&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&quot;amazon-rds-多可用区故障恢复&quot;&gt;Amazon RDS 多可用区故障恢复&lt;/h2&gt;

&lt;p&gt;只读实例也可以单独配置多可用区.&lt;/p&gt;

&lt;p&gt;此时会进行故障迁移, 一般需要 &lt;strong&gt;60-120秒&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&quot;aurroa-mysql-故障&quot;&gt;Aurroa Mysql 故障&lt;/h2&gt;

&lt;h3 id=&quot;写入器故障&quot;&gt;写入器故障&lt;/h3&gt;

&lt;p&gt;此时会进行故障迁移, 一般在&lt;strong&gt;30 秒&lt;/strong&gt;内完成&lt;/p&gt;

&lt;h3 id=&quot;读取器故障&quot;&gt;读取器故障&lt;/h3&gt;

&lt;p&gt;读取器需要进行硬件替换, 一般读取器实例故障耗时需要 &lt;strong&gt;5-10 分钟&lt;/strong&gt;来恢复, 也就是启动 EC2 实例的时间.&lt;/p&gt;

&lt;p&gt;读取器实例时无法配置多可用区.&lt;/p&gt;

&lt;h2 id=&quot;关于-aurora-mysql-读取器实例故障恢复时间过久解法&quot;&gt;关于 Aurora Mysql 读取器实例故障恢复时间过久解法&lt;/h2&gt;
&lt;h3 id=&quot;解法一-reader-endpoint&quot;&gt;解法一: reader endpoint&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;业务方使用reader endpoint, 且reader 节点的机器都是一样的, 有利于load balance.  如果极端情况下所有的reader node都挂了, reader endpoint可以利用上writer node, 这样就可以实时保障高可用了&lt;/li&gt;
  &lt;li&gt;减少 DNS 缓存超时,  将 Java DNS TTL 设置为较小的值有助于在后续连接尝试时在读取节点之间进行循环切换. 一般建议小于等于60s.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;解法二-rds-proxy&quot;&gt;解法二: rds proxy&lt;/h3&gt;

&lt;p&gt;参见: https://docs.aws.amazon.com/zh_cn/AmazonRDS/latest/AuroraUserGuide/rds-proxy.html#rds-proxy-failover&lt;/p&gt;</content><author><name>Chaim</name></author><category term="aws" /><category term="rds" /><summary type="html">故障原因 可用区中断 主数据库实例故障 更改数据库实例服务器类型 数据库实例的操作系统在进行软件修补 数据库实例的手动故障转移是使用 Reboot with failover 启动的。 Amazon RDS 单可用区故障恢复 无论是主数据库实例故障, 还是从数据库实例故障, 此时均为 EC2 启动并替换的时间, 一般需要 5-10 分钟. Amazon RDS 多可用区故障恢复 只读实例也可以单独配置多可用区. 此时会进行故障迁移, 一般需要 60-120秒. Aurroa Mysql 故障 写入器故障 此时会进行故障迁移, 一般在30 秒内完成 读取器故障 读取器需要进行硬件替换, 一般读取器实例故障耗时需要 5-10 分钟来恢复, 也就是启动 EC2 实例的时间. 读取器实例时无法配置多可用区. 关于 Aurora Mysql 读取器实例故障恢复时间过久解法 解法一: reader endpoint 业务方使用reader endpoint, 且reader 节点的机器都是一样的, 有利于load balance. 如果极端情况下所有的reader node都挂了, reader endpoint可以利用上writer node, 这样就可以实时保障高可用了 减少 DNS 缓存超时, 将 Java DNS TTL 设置为较小的值有助于在后续连接尝试时在读取节点之间进行循环切换. 一般建议小于等于60s. 解法二: rds proxy 参见: https://docs.aws.amazon.com/zh_cn/AmazonRDS/latest/AuroraUserGuide/rds-proxy.html#rds-proxy-failover</summary></entry><entry><title type="html">Git 几种工程推送方式</title><link href="http://localhost:4000/2020/08/12/Git-%E5%87%A0%E7%A7%8D%E5%B7%A5%E7%A8%8B%E6%8E%A8%E9%80%81%E6%96%B9%E5%BC%8F.html" rel="alternate" type="text/html" title="Git 几种工程推送方式" /><published>2020-08-12T00:00:00+08:00</published><updated>2020-08-12T00:00:00+08:00</updated><id>http://localhost:4000/2020/08/12/Git%20%E5%87%A0%E7%A7%8D%E5%B7%A5%E7%A8%8B%E6%8E%A8%E9%80%81%E6%96%B9%E5%BC%8F</id><content type="html" xml:base="http://localhost:4000/2020/08/12/Git-%E5%87%A0%E7%A7%8D%E5%B7%A5%E7%A8%8B%E6%8E%A8%E9%80%81%E6%96%B9%E5%BC%8F.html">&lt;h2 id=&quot;全局配置&quot;&gt;全局配置&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;git config --global user.name &quot;Chaim&quot;
git config --global user.email &quot;chaim@xxx.com&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;创建一个仓库&quot;&gt;创建一个仓库&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;git clone git@gitlab.xxx.net:groupname/test.git
cd test
touch README.md
git add README.md
git commit -m &quot;add README&quot;
git push -u origin master
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;推送一个存在的文件夹&quot;&gt;推送一个存在的文件夹&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;cd existing_folder
git init
git remote add origin git@gitlab.xxx.net:groupname/test.git
git add .
git commit -m &quot;Initial commit&quot;
git push -u origin master
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;推送一个存在的工程&quot;&gt;推送一个存在的工程&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;cd existing_repo
git remote rename origin old-origin
git remote add origin git@gitlab.xxx.net:groupname/test.git
git push -u origin --all
git push -u origin --tags
&lt;/code&gt;&lt;/pre&gt;</content><author><name>Chaim</name></author><category term="git" /><summary type="html">全局配置 git config --global user.name &quot;Chaim&quot; git config --global user.email &quot;chaim@xxx.com&quot; 创建一个仓库 git clone git@gitlab.xxx.net:groupname/test.git cd test touch README.md git add README.md git commit -m &quot;add README&quot; git push -u origin master 推送一个存在的文件夹 cd existing_folder git init git remote add origin git@gitlab.xxx.net:groupname/test.git git add . git commit -m &quot;Initial commit&quot; git push -u origin master 推送一个存在的工程 cd existing_repo git remote rename origin old-origin git remote add origin git@gitlab.xxx.net:groupname/test.git git push -u origin --all git push -u origin --tags</summary></entry><entry><title type="html">Golang Context 使用与理解</title><link href="http://localhost:4000/2020/08/10/Kubernates-Evicted-By-ephemeral-storage.html" rel="alternate" type="text/html" title="Golang Context 使用与理解" /><published>2020-08-10T00:00:00+08:00</published><updated>2020-08-10T00:00:00+08:00</updated><id>http://localhost:4000/2020/08/10/Kubernates%20Evicted%20By%20ephemeral-storage</id><content type="html" xml:base="http://localhost:4000/2020/08/10/Kubernates-Evicted-By-ephemeral-storage.html">&lt;h1 id=&quot;业务场景&quot;&gt;业务场景&lt;/h1&gt;

&lt;p&gt;用户发出请求后, 点击了取消. 此时该请求会对应几个 goroutine, 一个获取身份信息, 一个获取 db 数据, 一个校验 token. 一旦请求被取消, 该请求涉及到的其他 goroutine 也应该被取消&lt;/p&gt;

&lt;h1 id=&quot;实现方式&quot;&gt;实现方式&lt;/h1&gt;

&lt;h2 id=&quot;原始的-demo-处理过程&quot;&gt;原始的 Demo 处理过程&lt;/h2&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
	&lt;span class=&quot;s&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
	&lt;span class=&quot;s&quot;&gt;&quot;sync&quot;&lt;/span&gt;
	&lt;span class=&quot;s&quot;&gt;&quot;time&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wg&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sync&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WaitGroup&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;worker&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;worker&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;// 如何接收外部命令实现退出&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;wg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;wg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;worker&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;// 如何优雅的实现结束子goroutine&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;wg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;main done&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;全局变量方式处理&quot;&gt;全局变量方式处理&lt;/h2&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;sync&quot;&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;time&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wg&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sync&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WaitGroup&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// 全局变量方式存在的问题：&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// 1. 使用全局变量在跨包调用时不容易统一&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// 2. 如果worker中再启动goroutine，就不太好控制&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;worker&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;worker&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;wg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;wg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;worker&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Second&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// sleep3秒以免程序过快退出&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;true&lt;/span&gt;                 &lt;span class=&quot;c&quot;&gt;// 修改全局变量实现子goroutine的退出&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;wg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;main done&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;通道解决方式&quot;&gt;通道解决方式&lt;/h2&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;sync&quot;&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;time&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wg&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sync&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WaitGroup&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// 管道方式存在的问题：&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// 1. 使用全局变量在跨包调用时不容易实现规范和统一，需要维护一个共用的channel&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;worker&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;exitChan&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{})&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;LOOP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;worker&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;exitChan&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// 等待接收上级通知&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LOOP&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;wg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exitChan&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;make&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{})&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;wg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;worker&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;exitChan&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Second&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// sleep3秒以免程序过快退出&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;exitChan&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}{}&lt;/span&gt;      &lt;span class=&quot;c&quot;&gt;// 给子goroutine发送退出信号&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;exitChan&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;wg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;main done&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;官方推荐版本&quot;&gt;官方推荐版本&lt;/h2&gt;

&lt;p&gt;只需要将 context 对象传入, 即可以解决多个 goroutine 的上下文问题&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;context&quot;&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;sync&quot;&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;time&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wg&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sync&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WaitGroup&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;worker&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;LOOP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;worker&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// 等待上级通知&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LOOP&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;wg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancel&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WithCancel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Background&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;wg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;worker&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Second&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cancel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// 通知子goroutine结束&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;wg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;main done&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;context-是什么&quot;&gt;context 是什么&lt;/h1&gt;

&lt;h2 id=&quot;官方定义&quot;&gt;官方定义&lt;/h2&gt;

&lt;p&gt;Golang 1.7 之后加入了一个标准库 context. 该标准库定义为 Context 类型, 专门用于简化对于处理单个请求的多个 goroutine 之间与请求域的数据, 取消信号, 截止时间等相关操作, 这些操作往往涉及到调用多个 API.&lt;/p&gt;

&lt;h3 id=&quot;网络请求使用背景&quot;&gt;网络请求使用背景&lt;/h3&gt;

&lt;p&gt;如果有一个网络请求 request, 每个 request 都需要开启一个 goroutine 处理一些事情, 这些 goroutine 可能又会开启其他的 goroutine. 此时可以通过 context 来跟踪所有的 goroutine, 并且通过 context 来控制他们.&lt;/p&gt;

&lt;h3 id=&quot;服务器程序使用背景&quot;&gt;服务器程序使用背景&lt;/h3&gt;

&lt;p&gt;在 Go 服务器程序中, 每个请求都会有 goroutine 去处理. 然而, 处理程序往往还需要创建额外的 goroutine 去访问后端资源, 比如数据库, RPC 服务等. 由于 goroutine 都处理同一个请求, 往往还会访问一些共享的资源, 比如用户身份信息, 认证 token, 请求截止时间等. 如果请求超时或者被取消后, 所有的 goroutine 都应该马上退出, 并且释放相关资源. 此时就需要 context 来取消所有的 goroutine.&lt;/p&gt;

&lt;h3 id=&quot;context-接口定义&quot;&gt;context 接口定义&lt;/h3&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// A Context carries a deadline, a cancellation signal, and other values across&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// API boundaries.&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;//&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// Context's methods may be called by multiple goroutines simultaneously.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;// Deadline returns the time when work done on behalf of this context&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;// should be canceled. Deadline returns ok==false when no deadline is&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;// set. Successive calls to Deadline return the same results.&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Deadline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;deadline&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

	&lt;span class=&quot;c&quot;&gt;// Done returns a channel that's closed when work done on behalf of this&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;// context should be canceled. Done may return nil if this context can&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;// never be canceled. Successive calls to Done return the same value.&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;// The close of the Done channel may happen asynchronously,&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;// after the cancel function returns.&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;//&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;// WithCancel arranges for Done to be closed when cancel is called;&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;// WithDeadline arranges for Done to be closed when the deadline&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;// expires; WithTimeout arranges for Done to be closed when the timeout&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;// elapses.&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;//&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;// Done is provided for use in select statements:&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;//&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;//  // Stream generates values with DoSomething and sends them to out&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;//  // until DoSomething returns an error or ctx.Done is closed.&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;//  func Stream(ctx context.Context, out chan&amp;lt;- Value) error {&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;//  	for {&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;//  		v, err := DoSomething(ctx)&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;//  		if err != nil {&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;//  			return err&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;//  		}&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;//  		select {&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;//  		case &amp;lt;-ctx.Done():&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;//  			return ctx.Err()&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;//  		case out &amp;lt;- v:&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;//  		}&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;//  	}&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;//  }&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;//&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;// See https://blog.golang.org/pipelines for more examples of how to use&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;// a Done channel for cancellation.&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;

	&lt;span class=&quot;c&quot;&gt;// If Done is not yet closed, Err returns nil.&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;// If Done is closed, Err returns a non-nil error explaining why:&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;// Canceled if the context was canceled&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;// or DeadlineExceeded if the context's deadline passed.&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;// After Err returns a non-nil error, successive calls to Err return the same error.&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;

	&lt;span class=&quot;c&quot;&gt;// Value returns the value associated with this context for key, or nil&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;// if no value is associated with key. Successive calls to Value with&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;// the same key returns the same result.&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;//&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;// Use context values only for request-scoped data that transits&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;// processes and API boundaries, not for passing optional parameters to&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;// functions.&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;//&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;// A key identifies a specific value in a Context. Functions that wish&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;// to store values in Context typically allocate a key in a global&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;// variable then use that key as the argument to context.WithValue and&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;// Context.Value. A key can be any type that supports equality;&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;// packages should define keys as an unexported type to avoid&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;// collisions.&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;//&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;// Packages that define a Context key should provide type-safe accessors&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;// for the values stored using that key:&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;//&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;// 	// Package user defines a User type that's stored in Contexts.&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;// 	package user&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;//&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;// 	import &quot;context&quot;&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;//&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;// 	// User is the type of value stored in the Contexts.&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;// 	type User struct {...}&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;//&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;// 	// key is an unexported type for keys defined in this package.&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;// 	// This prevents collisions with keys defined in other packages.&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;// 	type key int&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;//&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;// 	// userKey is the key for user.User values in Contexts. It is&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;// 	// unexported; clients use user.NewContext and user.FromContext&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;// 	// instead of using this key directly.&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;// 	var userKey key&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;//&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;// 	// NewContext returns a new Context that carries value u.&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;// 	func NewContext(ctx context.Context, u *User) context.Context {&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;// 		return context.WithValue(ctx, userKey, u)&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;// 	}&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;//&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;// 	// FromContext returns the User value stored in ctx, if any.&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;// 	func FromContext(ctx context.Context) (*User, bool) {&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;// 		u, ok := ctx.Value(userKey).(*User)&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;// 		return u, ok&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;// 	}&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{})&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Deadline方法是获取设置的截止时间的意思，第一个返回是截止时间，到了这个时间点，Context会自动发起取消请求；第二个返回值ok==false时表示没有设置截止时间，如果需要取消的话，需要调用取消函数进行取消。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Done方法返回一个只读的chan，类型为struct{}，我们在goroutine中，如果该方法返回的chan可以读取，则意味着parent context已经发起了取消请求，我们通过Done方法收到这个信号后，就应该做清理操作，然后退出goroutine，释放资源。之后，Err 方法会返回一个错误，告知为什么 Context 被取消。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Err方法返回取消的错误原因，因为什么Context被取消。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Value方法获取该Context上绑定的值，是一个键值对，所以要通过一个Key才可以获取对应的值，这个值一般是线程安全的。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;context-实现方法&quot;&gt;context 实现方法&lt;/h1&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;background&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;emptyCtx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;todo&lt;/span&gt;       &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;emptyCtx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// Background returns a non-nil, empty Context. It is never canceled, has no&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// values, and has no deadline. It is typically used by the main function,&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// initialization, and tests, and as the top-level Context for incoming&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// requests.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Background&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;background&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// TODO returns a non-nil, empty Context. Code should use context.TODO when&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// it's unclear which Context to use or it is not yet available (because the&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// surrounding function has not yet been extended to accept a Context&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// parameter).&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TODO&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;todo&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;background-方法&quot;&gt;Background 方法&lt;/h2&gt;

&lt;p&gt;该方法主要用于 main 函数, 初始化以及测试代码中, 作为 context 的树结构的最顶层 context, 也被称为根 context, 不能被取消&lt;/p&gt;

&lt;h2 id=&quot;todo-方法&quot;&gt;TODO 方法&lt;/h2&gt;

&lt;p&gt;如果不知道使用什么 context 时候, 可以使用这个.&lt;/p&gt;

&lt;h2 id=&quot;emptyctx-本质&quot;&gt;emptyCtx 本质&lt;/h2&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// An emptyCtx is never canceled, has no values, and has no deadline. It is not&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// struct{}, since vars of this type must have distinct addresses.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;emptyCtx&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;emptyCtx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Deadline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;deadline&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;emptyCtx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;emptyCtx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;emptyCtx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{})&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;emptyCtx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;switch&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;background&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;context.Background&quot;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;todo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;context.TODO&quot;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;unknown empty Context&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Background 以及 TODO 实际上都是返回了一个 emptyCtx 实例. 实现的 Deadline 方法中均未不可手动取消&lt;/p&gt;

&lt;h2 id=&quot;context-继承&quot;&gt;context 继承&lt;/h2&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WithCancel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancel&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CancelFunc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WithDeadline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;deadline&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CancelFunc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WithTimeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Duration&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CancelFunc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WithValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{})&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;WithCancel函数，传递一个父Context作为参数，返回子Context，以及一个取消函数用来取消Context。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;WithDeadline函数，和WithCancel差不多，它会多传递一个截止时间参数，意味着到了这个时间点，会自动取消Context，当然我们也可以不等到这个时候，可以提前通过取消函数进行取消。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;WithTimeout和WithDeadline基本上一样，这个表示是超时自动取消，是多少时间后自动取消Context的意思。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;WithValue函数和取消Context无关，它是为了生成一个绑定了一个键值对数据的Context，这个绑定的数据可以通过Context.Value方法访问到，这是我们实际用经常要用到的技巧，一般我们想要通过上下文来传递数据时，可以通过这个方法，如我们需要tarce追踪系统调用栈的时候。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>Chaim</name></author><category term="golang" /><category term="context" /><summary type="html">业务场景 用户发出请求后, 点击了取消. 此时该请求会对应几个 goroutine, 一个获取身份信息, 一个获取 db 数据, 一个校验 token. 一旦请求被取消, 该请求涉及到的其他 goroutine 也应该被取消 实现方式 原始的 Demo 处理过程 package main import ( &quot;fmt&quot; &quot;sync&quot; &quot;time&quot; ) var wg sync.WaitGroup func worker() { for { fmt.Println(&quot;worker&quot;) time.Sleep(time.Second) } // 如何接收外部命令实现退出 wg.Done() } func main() { wg.Add(1) go worker() // 如何优雅的实现结束子goroutine wg.Wait() fmt.Println(&quot;main done&quot;) } 全局变量方式处理 package main import ( &quot;fmt&quot; &quot;sync&quot; &quot;time&quot; ) var wg sync.WaitGroup var exit bool // 全局变量方式存在的问题： // 1. 使用全局变量在跨包调用时不容易统一 // 2. 如果worker中再启动goroutine，就不太好控制 func worker() { for { fmt.Println(&quot;worker&quot;) time.Sleep(time.Second) if exit { break } } wg.Done() } func main() { wg.Add(1) go worker() time.Sleep(time.Second * 3) // sleep3秒以免程序过快退出 exit = true // 修改全局变量实现子goroutine的退出 wg.Wait() fmt.Println(&quot;main done&quot;) } 通道解决方式 package main import ( &quot;fmt&quot; &quot;sync&quot; &quot;time&quot; ) var wg sync.WaitGroup // 管道方式存在的问题： // 1. 使用全局变量在跨包调用时不容易实现规范和统一，需要维护一个共用的channel func worker(exitChan chan struct{}) { LOOP: for { fmt.Println(&quot;worker&quot;) time.Sleep(time.Second) select { case &amp;lt;-exitChan: // 等待接收上级通知 break LOOP default: } } wg.Done() } func main() { var exitChan = make(chan struct{}) wg.Add(1) go worker(exitChan) time.Sleep(time.Second * 3) // sleep3秒以免程序过快退出 exitChan &amp;lt;- struct{}{} // 给子goroutine发送退出信号 close(exitChan) wg.Wait() fmt.Println(&quot;main done&quot;) } 官方推荐版本 只需要将 context 对象传入, 即可以解决多个 goroutine 的上下文问题 package main import ( &quot;context&quot; &quot;fmt&quot; &quot;sync&quot; &quot;time&quot; ) var wg sync.WaitGroup func worker(ctx context.Context) { LOOP: for { fmt.Println(&quot;worker&quot;) time.Sleep(time.Second) select { case &amp;lt;-ctx.Done(): // 等待上级通知 break LOOP default: } } wg.Done() } func main() { ctx, cancel := context.WithCancel(context.Background()) wg.Add(1) go worker(ctx) time.Sleep(time.Second * 3) cancel() // 通知子goroutine结束 wg.Wait() fmt.Println(&quot;main done&quot;) } context 是什么 官方定义 Golang 1.7 之后加入了一个标准库 context. 该标准库定义为 Context 类型, 专门用于简化对于处理单个请求的多个 goroutine 之间与请求域的数据, 取消信号, 截止时间等相关操作, 这些操作往往涉及到调用多个 API. 网络请求使用背景 如果有一个网络请求 request, 每个 request 都需要开启一个 goroutine 处理一些事情, 这些 goroutine 可能又会开启其他的 goroutine. 此时可以通过 context 来跟踪所有的 goroutine, 并且通过 context 来控制他们. 服务器程序使用背景 在 Go 服务器程序中, 每个请求都会有 goroutine 去处理. 然而, 处理程序往往还需要创建额外的 goroutine 去访问后端资源, 比如数据库, RPC 服务等. 由于 goroutine 都处理同一个请求, 往往还会访问一些共享的资源, 比如用户身份信息, 认证 token, 请求截止时间等. 如果请求超时或者被取消后, 所有的 goroutine 都应该马上退出, 并且释放相关资源. 此时就需要 context 来取消所有的 goroutine. context 接口定义 // A Context carries a deadline, a cancellation signal, and other values across // API boundaries. // // Context's methods may be called by multiple goroutines simultaneously. type Context interface { // Deadline returns the time when work done on behalf of this context // should be canceled. Deadline returns ok==false when no deadline is // set. Successive calls to Deadline return the same results. Deadline() (deadline time.Time, ok bool) // Done returns a channel that's closed when work done on behalf of this // context should be canceled. Done may return nil if this context can // never be canceled. Successive calls to Done return the same value. // The close of the Done channel may happen asynchronously, // after the cancel function returns. // // WithCancel arranges for Done to be closed when cancel is called; // WithDeadline arranges for Done to be closed when the deadline // expires; WithTimeout arranges for Done to be closed when the timeout // elapses. // // Done is provided for use in select statements: // // // Stream generates values with DoSomething and sends them to out // // until DoSomething returns an error or ctx.Done is closed. // func Stream(ctx context.Context, out chan&amp;lt;- Value) error { // for { // v, err := DoSomething(ctx) // if err != nil { // return err // } // select { // case &amp;lt;-ctx.Done(): // return ctx.Err() // case out &amp;lt;- v: // } // } // } // // See https://blog.golang.org/pipelines for more examples of how to use // a Done channel for cancellation. Done() &amp;lt;-chan struct{} // If Done is not yet closed, Err returns nil. // If Done is closed, Err returns a non-nil error explaining why: // Canceled if the context was canceled // or DeadlineExceeded if the context's deadline passed. // After Err returns a non-nil error, successive calls to Err return the same error. Err() error // Value returns the value associated with this context for key, or nil // if no value is associated with key. Successive calls to Value with // the same key returns the same result. // // Use context values only for request-scoped data that transits // processes and API boundaries, not for passing optional parameters to // functions. // // A key identifies a specific value in a Context. Functions that wish // to store values in Context typically allocate a key in a global // variable then use that key as the argument to context.WithValue and // Context.Value. A key can be any type that supports equality; // packages should define keys as an unexported type to avoid // collisions. // // Packages that define a Context key should provide type-safe accessors // for the values stored using that key: // // // Package user defines a User type that's stored in Contexts. // package user // // import &quot;context&quot; // // // User is the type of value stored in the Contexts. // type User struct {...} // // // key is an unexported type for keys defined in this package. // // This prevents collisions with keys defined in other packages. // type key int // // // userKey is the key for user.User values in Contexts. It is // // unexported; clients use user.NewContext and user.FromContext // // instead of using this key directly. // var userKey key // // // NewContext returns a new Context that carries value u. // func NewContext(ctx context.Context, u *User) context.Context { // return context.WithValue(ctx, userKey, u) // } // // // FromContext returns the User value stored in ctx, if any. // func FromContext(ctx context.Context) (*User, bool) { // u, ok := ctx.Value(userKey).(*User) // return u, ok // } Value(key interface{}) interface{} } Deadline方法是获取设置的截止时间的意思，第一个返回是截止时间，到了这个时间点，Context会自动发起取消请求；第二个返回值ok==false时表示没有设置截止时间，如果需要取消的话，需要调用取消函数进行取消。 Done方法返回一个只读的chan，类型为struct{}，我们在goroutine中，如果该方法返回的chan可以读取，则意味着parent context已经发起了取消请求，我们通过Done方法收到这个信号后，就应该做清理操作，然后退出goroutine，释放资源。之后，Err 方法会返回一个错误，告知为什么 Context 被取消。 Err方法返回取消的错误原因，因为什么Context被取消。 Value方法获取该Context上绑定的值，是一个键值对，所以要通过一个Key才可以获取对应的值，这个值一般是线程安全的。 context 实现方法 var ( background = new(emptyCtx) todo = new(emptyCtx) ) // Background returns a non-nil, empty Context. It is never canceled, has no // values, and has no deadline. It is typically used by the main function, // initialization, and tests, and as the top-level Context for incoming // requests. func Background() Context { return background } // TODO returns a non-nil, empty Context. Code should use context.TODO when // it's unclear which Context to use or it is not yet available (because the // surrounding function has not yet been extended to accept a Context // parameter). func TODO() Context { return todo } Background 方法 该方法主要用于 main 函数, 初始化以及测试代码中, 作为 context 的树结构的最顶层 context, 也被称为根 context, 不能被取消 TODO 方法 如果不知道使用什么 context 时候, 可以使用这个. emptyCtx 本质 // An emptyCtx is never canceled, has no values, and has no deadline. It is not // struct{}, since vars of this type must have distinct addresses. type emptyCtx int func (*emptyCtx) Deadline() (deadline time.Time, ok bool) { return } func (*emptyCtx) Done() &amp;lt;-chan struct{} { return nil } func (*emptyCtx) Err() error { return nil } func (*emptyCtx) Value(key interface{}) interface{} { return nil } func (e *emptyCtx) String() string { switch e { case background: return &quot;context.Background&quot; case todo: return &quot;context.TODO&quot; } return &quot;unknown empty Context&quot; } Background 以及 TODO 实际上都是返回了一个 emptyCtx 实例. 实现的 Deadline 方法中均未不可手动取消 context 继承 func WithCancel(parent Context) (ctx Context, cancel CancelFunc) func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc) func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) func WithValue(parent Context, key, val interface{}) Context WithCancel函数，传递一个父Context作为参数，返回子Context，以及一个取消函数用来取消Context。 WithDeadline函数，和WithCancel差不多，它会多传递一个截止时间参数，意味着到了这个时间点，会自动取消Context，当然我们也可以不等到这个时候，可以提前通过取消函数进行取消。 WithTimeout和WithDeadline基本上一样，这个表示是超时自动取消，是多少时间后自动取消Context的意思。 WithValue函数和取消Context无关，它是为了生成一个绑定了一个键值对数据的Context，这个绑定的数据可以通过Context.Value方法访问到，这是我们实际用经常要用到的技巧，一般我们想要通过上下文来传递数据时，可以通过这个方法，如我们需要tarce追踪系统调用栈的时候。</summary></entry><entry><title type="html">Kubernates Evicted By ephemeral-storage</title><link href="http://localhost:4000/2020/08/10/Golang-Context-%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%90%86%E8%A7%A3.html" rel="alternate" type="text/html" title="Kubernates Evicted By ephemeral-storage" /><published>2020-08-10T00:00:00+08:00</published><updated>2020-08-10T00:00:00+08:00</updated><id>http://localhost:4000/2020/08/10/Golang%20Context%20%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%90%86%E8%A7%A3</id><content type="html" xml:base="http://localhost:4000/2020/08/10/Golang-Context-%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%90%86%E8%A7%A3.html">&lt;h2 id=&quot;报错如下&quot;&gt;报错如下&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  Type     Reason     Age                From                                     Message
  ----     ------     ----               ----                                     -------
  Warning  Unhealthy  52m                kubelet, ip-172-30-200-182.ec2.internal  Readiness probe failed: Get http://172.30.206.82:10902/-/ready: dial tcp 172.30.206.82:10902: connect: connection refused
  Normal   Pulled     52m (x2 over 22h)  kubelet, ip-172-30-200-182.ec2.internal  Container image &quot;quay.io/thanos/thanos:v0.14.0&quot; already present on machine
  Normal   Created    52m (x2 over 22h)  kubelet, ip-172-30-200-182.ec2.internal  Created container thanos
  Normal   Started    52m (x2 over 22h)  kubelet, ip-172-30-200-182.ec2.internal  Started container thanos
  Warning  Evicted    28m                kubelet, ip-172-30-200-182.ec2.internal  The node was low on resource: ephemeral-storage. Container prometheus was using 20Ki, which exceeds its request of 0. Container thanos was using 16Ki, which exceeds its request of 0.
  Normal   Killing    28m                kubelet, ip-172-30-200-182.ec2.internal  Stopping container prometheus
  Normal   Killing    28m                kubelet, ip-172-30-200-182.ec2.internal  Stopping container thanos
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;解决办法&quot;&gt;解决办法&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        resources:
          limits:
            cpu: &quot;1500m&quot;
            memory: &quot;14.5Gi&quot;
            ephemeral-storage: &quot;10Gi&quot;
          requests:
            cpu: &quot;1500m&quot;
            memory: &quot;14.5Gi&quot;
            ephemeral-storage: &quot;10Gi&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Chaim</name></author><category term="kubernates" /><category term="evicted" /><summary type="html">报错如下 Type Reason Age From Message ---- ------ ---- ---- ------- Warning Unhealthy 52m kubelet, ip-172-30-200-182.ec2.internal Readiness probe failed: Get http://172.30.206.82:10902/-/ready: dial tcp 172.30.206.82:10902: connect: connection refused Normal Pulled 52m (x2 over 22h) kubelet, ip-172-30-200-182.ec2.internal Container image &quot;quay.io/thanos/thanos:v0.14.0&quot; already present on machine Normal Created 52m (x2 over 22h) kubelet, ip-172-30-200-182.ec2.internal Created container thanos Normal Started 52m (x2 over 22h) kubelet, ip-172-30-200-182.ec2.internal Started container thanos Warning Evicted 28m kubelet, ip-172-30-200-182.ec2.internal The node was low on resource: ephemeral-storage. Container prometheus was using 20Ki, which exceeds its request of 0. Container thanos was using 16Ki, which exceeds its request of 0. Normal Killing 28m kubelet, ip-172-30-200-182.ec2.internal Stopping container prometheus Normal Killing 28m kubelet, ip-172-30-200-182.ec2.internal Stopping container thanos 解决办法 resources: limits: cpu: &quot;1500m&quot; memory: &quot;14.5Gi&quot; ephemeral-storage: &quot;10Gi&quot; requests: cpu: &quot;1500m&quot; memory: &quot;14.5Gi&quot; ephemeral-storage: &quot;10Gi&quot;</summary></entry><entry><title type="html">EBS 扩容</title><link href="http://localhost:4000/2020/08/07/EBS-%E6%89%A9%E5%AE%B9.html" rel="alternate" type="text/html" title="EBS 扩容" /><published>2020-08-07T00:00:00+08:00</published><updated>2020-08-07T00:00:00+08:00</updated><id>http://localhost:4000/2020/08/07/EBS%20%E6%89%A9%E5%AE%B9</id><content type="html" xml:base="http://localhost:4000/2020/08/07/EBS-%E6%89%A9%E5%AE%B9.html">&lt;h2 id=&quot;控制台直接修改-ebs-大小&quot;&gt;控制台直接修改 ebs 大小&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/chaimch/FigureBed@master/uPic/image-20200807120654364.png&quot; alt=&quot;image-20200807120654364&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;修改对应-ec2-的文件系统&quot;&gt;修改对应 ec2 的文件系统&lt;/h2&gt;

&lt;h3 id=&quot;根分区-&quot;&gt;根分区 /&lt;/h3&gt;

&lt;p&gt;直接重启实例才能生效&lt;/p&gt;

&lt;h3 id=&quot;文件系统&quot;&gt;文件系统&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;查看文件系统使用情况&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[ec2-user@ip-172-30-30-72 ~]$ df -h
文件系统        容量  已用  可用 已用% 挂载点
devtmpfs         32G     0   32G    0% /dev
tmpfs            32G     0   32G    0% /dev/shm
tmpfs            32G  684K   32G    1% /run
tmpfs            32G     0   32G    0% /sys/fs/cgroup
/dev/nvme0n1p1   20G  2.4G   18G   12% /
/dev/nvme1n1     80G   80G   20K  100% /home
tmpfs           6.3G     0  6.3G    0% /run/user/1000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;扩展文件系统&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo yum install xfsprogs
sudo xfs_growfs -d /home
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Chaim</name></author><category term="aws" /><category term="ebs" /><summary type="html">控制台直接修改 ebs 大小 修改对应 ec2 的文件系统 根分区 / 直接重启实例才能生效 文件系统 查看文件系统使用情况 [ec2-user@ip-172-30-30-72 ~]$ df -h 文件系统 容量 已用 可用 已用% 挂载点 devtmpfs 32G 0 32G 0% /dev tmpfs 32G 0 32G 0% /dev/shm tmpfs 32G 684K 32G 1% /run tmpfs 32G 0 32G 0% /sys/fs/cgroup /dev/nvme0n1p1 20G 2.4G 18G 12% / /dev/nvme1n1 80G 80G 20K 100% /home tmpfs 6.3G 0 6.3G 0% /run/user/1000 扩展文件系统 sudo yum install xfsprogs sudo xfs_growfs -d /home</summary></entry><entry><title type="html">Mac禁用option组合键特殊字符.md</title><link href="http://localhost:4000/2020/08/07/Mac-%E7%A6%81%E7%94%A8-option-%E7%BB%84%E5%90%88%E9%94%AE%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6.html" rel="alternate" type="text/html" title="Mac禁用option组合键特殊字符.md" /><published>2020-08-07T00:00:00+08:00</published><updated>2020-08-07T00:00:00+08:00</updated><id>http://localhost:4000/2020/08/07/Mac%20%E7%A6%81%E7%94%A8%20option%20%E7%BB%84%E5%90%88%E9%94%AE%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6</id><content type="html" xml:base="http://localhost:4000/2020/08/07/Mac-%E7%A6%81%E7%94%A8-option-%E7%BB%84%E5%90%88%E9%94%AE%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6.html">&lt;h1 id=&quot;iterm2-中&quot;&gt;Iterm2 中&lt;/h1&gt;

&lt;h2 id=&quot;操作步骤&quot;&gt;操作步骤&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;Preference&lt;/li&gt;
  &lt;li&gt;Profiles&lt;/li&gt;
  &lt;li&gt;default&lt;/li&gt;
  &lt;li&gt;keys&lt;/li&gt;
  &lt;li&gt;set option 为 Esc+&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/chaimch/FigureBed@master/uPic/image-20200623142907502.png&quot; alt=&quot;image-20200623142907502&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;vscode-中解决打开-terminal-时候使用-option-仍冲突&quot;&gt;vscode 中(解决打开 terminal 时候使用 option 仍冲突)&lt;/h1&gt;

&lt;h2 id=&quot;操作步骤-1&quot;&gt;操作步骤&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;cmd + shif +p&lt;/li&gt;
  &lt;li&gt;open settings (ui)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/chaimch/FigureBed@master/uPic/image-20200623143042248.png&quot; alt=&quot;image-20200623143042248&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;terminal.integrated.macOptionIsMeta 为 true&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/chaimch/FigureBed@master/uPic/image-20200623143131118.png&quot; alt=&quot;image-20200623143131118&quot; /&gt;&lt;/p&gt;</content><author><name>Chaim</name></author><category term="mac" /><category term="option" /><summary type="html">Iterm2 中 操作步骤 Preference Profiles default keys set option 为 Esc+ vscode 中(解决打开 terminal 时候使用 option 仍冲突) 操作步骤 cmd + shif +p open settings (ui) terminal.integrated.macOptionIsMeta 为 true</summary></entry><entry><title type="html">Vim Cheatsheet</title><link href="http://localhost:4000/2020/08/07/Vim-Cheatsheet.html" rel="alternate" type="text/html" title="Vim Cheatsheet" /><published>2020-08-07T00:00:00+08:00</published><updated>2020-08-07T00:00:00+08:00</updated><id>http://localhost:4000/2020/08/07/Vim%20Cheatsheet</id><content type="html" xml:base="http://localhost:4000/2020/08/07/Vim-Cheatsheet.html">&lt;h2 id=&quot;命令执行格式&quot;&gt;命令执行格式&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(command) (number) (text object)
(number) (command) (text object) 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;基础操作&quot;&gt;基础操作&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ZZ 或 :wq                 保存并退出
:e!                       恢复到上一次存储的文件内容
:w pathname/filename      写入到其他文件中
:rf pathname/filename     删除其他文件
:!ls pathname             查看其他目录使用情况
:sh -&amp;gt; ctrl-d 或 exit     创建对应的 shell 执行其任务后再返回
ctrl-z -&amp;gt; fg              暂停 vi 后执行对应的任务后再返回
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;按字符光标移动&quot;&gt;按字符光标移动&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;h/l                       左/右 移动一个字符
4l                        向右 4 个字符
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;按行光标移动&quot;&gt;按行光标移动&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0                         移动到行首
$                         移动到行尾
^                         移到当前行第一个非空格处
10|                       移到当前行第 10 列

j/k                       上一行/下一行
2j                        向上移动 2 行

G                         移动到文件的结尾
1G                        移动到文件的第一行
ctrk-g                    屏幕底部显示信息, 包含行号, 文件总行数, 当前位置占全文的百分比
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;按照文本块移动&quot;&gt;按照文本块移动&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;w                        移动一个单词, 包含符号与标点
W                        移动一个单词, 不包含符号与标点
2w                       移动两个单词

b                        倒退一个单词, 包含符号与标点
B                        倒退一个单词, 不好干符号与标点

e                        移到单词的尾部
E                        移到单词的尾部, 忽略标点符号

(                        移到当前句子的开头, 标点符号后有两个空格或者一行的最后一个非空格字符时候为一个句子
)                        移到下一个句子的开头
3)                       向上移动 3 个句子

{                        移到当前这一段的开头, 段落指的是空白行下的文本
}                        移到下一段的开头

[[                       移到当前这一节的开头
]]                       移到下一节的开头
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;简单的文件编辑&quot;&gt;简单的文件编辑&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;i                        insert, 插入
a                        add, 添加
c                        change, 更改
d                        delete, 删除后放到缓冲区
p                        paste, 粘贴, d -&amp;gt; p 可以移动行
y                        复制

cw                       表示更改整个单词

x                        删除一个字符
r                        重写改写一个字符
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;添加文本&quot;&gt;添加文本&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a                        光标之后添加
A                        行结尾添加

i                        光标之前添加
I                        行开头添加

o                        光标位置下一行打开新行添加
O                        光标位置上一行打开新行添加
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;修改文本-需告知有多少文本要修改-可结合光标移动命令使用&quot;&gt;修改文本, 需告知有多少文本要修改, 可结合光标移动命令使用&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cw                       光标到单词结尾要修改, 因此可以用英语单词的部分修改, 只要光标停留在需要修改的开始位置即可
c2b                      光标往前 2 个字符
c$ 或 C                  光标到本行结尾
c0                       光标到此行开头
cc                       修改整行文本
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;替换文本&quot;&gt;替换文本&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;r                        替换一个字符
2r                       同时替换两个字符
R                        替换整行, 逐渐覆盖

s                        替换一个字符, 先删除字符, 并进入插入模式, 因此可以用于将一个字符替换为多个的情况
S                        替换整行, 先删除整行, 并进入插入模式
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;修改大小写&quot;&gt;修改大小写&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~                        修改一个字符为大写或者小写
3~                       修改三个字符为大写或者小写
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;删除文本-需要告知有多少文本需要删除-可结合光标移动命令使用&quot;&gt;删除文本, 需要告知有多少文本需要删除, 可结合光标移动命令使用&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dw                      删除光标到单词尾部的字符, 包含单词尾部的空白
de                      删除光标到单词本身尾部的字符, 不包含尾部后边的空白
dE                      删除光标到单词尾部, 包含标点符号

db                      向前删除一个字符
d0                      删除光标到行开头的字符
d$ 或 D                 删除光标到结尾的字符

dd                      删除一整行字符
2dd                     删除两行字符

x                       x-ing out 打印机消除的意思, 删除一个字符
2x                      删除两个字符
X                       删除光标之前的一个字符
2X                      删除光标之前的两个字符
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;误删恢复&quot;&gt;误删恢复&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;u                       撤销上一个命令
3p                      将第三个缓冲区放到下一行, 默认保留九个缓冲区
ctrl-r                  重做一次撤销操作
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;移动文本-采用先删除后放置的方法&quot;&gt;移动文本, 采用先删除后放置的方法&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;p                       将缓冲区文本放到光标之后, 单行则放到同一行, 多行缓冲区则另起一行
P                       将缓冲区文本放到光标之前
xp                      对调两个字符
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;复制文本-需要告知有多少文本需要复制-可结合光标移动命令使用&quot;&gt;复制文本, 需要告知有多少文本需要复制, 可结合光标移动命令使用&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yw                      复制光标到单词尾部的字符
y0                      复制光标到行开头的字符
y$                      复制光标到行结尾的字符
yy 或 Y                  复制整行内容
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;重复命令-每个命令均会被存储到一个临时的缓冲区-直到发出下一个命令为主&quot;&gt;重复命令, 每个命令均会被存储到一个临时的缓冲区, 直到发出下一个命令为主&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.                       重复上一次的命令
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;合并行&quot;&gt;合并行&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;J                        合并两行, 将当前行与下一行合并
3J                       合并三行
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;编辑命令&quot;&gt;编辑命令&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;文本对象&lt;/th&gt;
      &lt;th&gt;更改&lt;/th&gt;
      &lt;th&gt;删除&lt;/th&gt;
      &lt;th&gt;复制&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;单个字符&lt;/td&gt;
      &lt;td&gt;r&lt;/td&gt;
      &lt;td&gt;x&lt;/td&gt;
      &lt;td&gt;yl&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;五个字符&lt;/td&gt;
      &lt;td&gt;5s&lt;/td&gt;
      &lt;td&gt;5x&lt;/td&gt;
      &lt;td&gt;y5l&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;一个单词&lt;/td&gt;
      &lt;td&gt;cw&lt;/td&gt;
      &lt;td&gt;dw&lt;/td&gt;
      &lt;td&gt;yw&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;两个单词, 不包含标点符号&lt;/td&gt;
      &lt;td&gt;c2W&lt;/td&gt;
      &lt;td&gt;d2W&lt;/td&gt;
      &lt;td&gt;y2W&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;后退三个单词&lt;/td&gt;
      &lt;td&gt;c2b&lt;/td&gt;
      &lt;td&gt;d2b&lt;/td&gt;
      &lt;td&gt;y2b&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;一整行&lt;/td&gt;
      &lt;td&gt;cc&lt;/td&gt;
      &lt;td&gt;dd&lt;/td&gt;
      &lt;td&gt;yy&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;到一行的结尾&lt;/td&gt;
      &lt;td&gt;c$ 或 C&lt;/td&gt;
      &lt;td&gt;d$ 或 D&lt;/td&gt;
      &lt;td&gt;y$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;到一行的开头&lt;/td&gt;
      &lt;td&gt;c0&lt;/td&gt;
      &lt;td&gt;d0&lt;/td&gt;
      &lt;td&gt;y0&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;光标移动命令&quot;&gt;光标移动命令&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;移动
命令
←↓↑→
hjkl
下一行第一个字符
+
上一行第一个字符
-
单词结尾
e 或 E
往前一个单词
w 或 W
往后一个单词
b 或 B
到一行的结尾
$
到一行的开头
0
往缓冲区放置文本
p 或 P
保存编辑结果并离开
ZZ
不保存编辑结果并离开
:q!
光标所在位置插入文本
i
一行开头插入文本
I
光标所在位置附加文本
a
一行最后附加文本
A
光标下一行打开新行
o
光标上一行打开新行
O
删除一行并替换文本
S
新文本覆盖现有文本
R
合并当前行与下一行
J
重复上一个动作
.
撤销上一个动作
u
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;滚动屏幕&quot;&gt;滚动屏幕&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;z-enter               移动当前行到屏幕顶端并滚动屏幕
z.                    移动当前行到屏幕中心并滚动屏幕
z-                    移动当前

ctrl-f                forward, 向上滚动一屏
ctrl-b                backward, 向下滚动一屏

ctrl-u                up, 向上滚动半屏
ctrl-d                down, 向下滚动半屏

100z                  将第一百行滚动到屏幕顶端
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;光标在屏幕中移动&quot;&gt;光标在屏幕中移动&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;H                    high, 移到屏幕顶端的行
M                    middle, 移到屏幕中间的行
L                    low, 移到屏幕底部的行
10H                  移到屏幕顶端往下的第十行
10L                  移到屏幕底部往上的第十行
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;根据搜索模式来移动&quot;&gt;根据搜索模式来移动&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/                    向下匹配搜索
?                    向上匹配搜索
n                    往同一个方向重复搜索
N                    往相反方向重复搜索
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;在当前行搜索&quot;&gt;在当前行搜索&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fx                   光标移到本行出现下一个 x 字符的地方
2fx                  搜索本行第二次出现 x 字符的地方
Fx                   光标移到本行出现上一个 x 字符的地方

tx                   光标移到本行出现下一个 x 字符的地方的前一个字符
Tx                   光标移到本行出现上一个 x 字符的地方的后一个字符

;                    重复上一个搜索命令, 方向相同
,                    重复下一个搜索命令, 方向相反

''                   回到上一个包含记号的行开头
``                   回到上一个记号或上下文
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;百花齐放的打开文件&quot;&gt;百花齐放的打开文件&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vi  +n  file        在第 n 行打开文件
vi  + file          在最后一行打开文件
vi  +/pattern file  在第一个出现 pattern 的地方打开文件
vi  -R  file        只读模式显示文件
vi  -r  file        恢复编辑缓冲区
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;缓冲区使用&quot;&gt;缓冲区使用&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# vi 会将最后 9 次的删除操作保存在编号的缓冲区中, 1-9 的缓冲区, 1 表示最后一次的删除
# vi 会将复制的文本放在按字母标识的缓冲区中, a-z 的缓冲区

&quot;1p                恢复最后一次的删除内容, 光标之后插入
&quot;1pu.              逐一将缓冲区内容放置到当前光标之后, u会删除文本, .则重复放置, 不断轮换知道找到所需的文本

&quot;dyy               将当前行复制到缓冲区 d 中, &quot;加上缓冲区名字, 可以用于命名缓冲区
&quot;dP                将缓冲区 d 中内容放置到光标之前
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;对某一处做标记&quot;&gt;对某一处做标记&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mx                将当前位置标记成 x

'x                单引号, 将光标移动到 x 标记所在的第一行
''                两个单引号, 回到上一个标记或上下文所在行的开头

`x                反引号, 将光标移到以 x 标记的字符位置
``                两个反引号, 回到上一个标记或上下文的确切位置
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;vi-缓冲区与标记命令&quot;&gt;vi 缓冲区与标记命令&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;命令&lt;/th&gt;
      &lt;th&gt;意义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;+n  file&lt;/td&gt;
      &lt;td&gt;在第 n 行打开 file&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;+ file&lt;/td&gt;
      &lt;td&gt;在最后一行打开 file&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;+ /pattern file&lt;/td&gt;
      &lt;td&gt;在第一个出现 pattern 的地方打开 file&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-c command file&lt;/td&gt;
      &lt;td&gt;在打开文件后执行命令, 通常是行号或者搜索模式, eg: vi -c /gitlab practice.txt&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-R&lt;/td&gt;
      &lt;td&gt;用只读模式打开文件, 与 view 命令相同&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-r&lt;/td&gt;
      &lt;td&gt;死机后恢复文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1-9&lt;/td&gt;
      &lt;td&gt;最后 9 次删除操作的内容, 最后一次-最先一次&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;a-z&lt;/td&gt;
      &lt;td&gt;可以使用的命名缓冲区, 大写字母表示附加到缓冲区现有内容后&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;“b command&lt;/td&gt;
      &lt;td&gt;用缓冲区b 执行命令&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;mx&lt;/td&gt;
      &lt;td&gt;将当前位置标记为 x&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;‘x&lt;/td&gt;
      &lt;td&gt;将光标移动到标记 x 所在行的第一个字符&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;~x&lt;/td&gt;
      &lt;td&gt;将光标移动到用 x 标记的字符&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;’’&lt;/td&gt;
      &lt;td&gt;回到上一个标记或上下文所在行的开头&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;``&lt;/td&gt;
      &lt;td&gt;回到上一个标记或上下文的确切位置&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;ex-命令&quot;&gt;ex 命令&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:1p                         打印第 1 行
:1                          打印第 1 行
:1,3                        打印 1-3 行

:1s/GitLab/gitlab           替换第一行的 GitLab 为 gitlab
:s/GitLab/gitlab            在当前行替换 GitLab 为 gitlab

:vi                         ex 模式下转换为 vi 模式
Q                           vi 模式下转换为 ex 模式

:1,3d                       delete 可简写为 d, 删除第 1 行到第 3 行
:1m2                        move 可简写为 m, 将第 1 行移到第 2 行之后
:1co2                       copy 可简写为 co, 与 t 同意, 将第 1 行复制到第 2 行之后

:set nu                     number 可简写为 nu, 设置显示行号
:set nonu                   no number 可简写为 nobu, 禁用显示行号
:1,10#                      暂时显示 1-10 行的行号

:=                          列出文件的总行数
:.=                         列出当前所在行的行号
:/pattern/=                 列出 patter 第一次出现的行号

:.                          表示当前这一行
:$                          表示文件最后一行
:%                          表示文件中每一行
:.,+20#                     显示当前这一行以及向下 20 行直接的行号
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;ex-搜索模式&quot;&gt;ex 搜索模式&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:/pattern/d                 删除下一个包含 pattern 的行
:.,/pattern/d               删除当前行以及第一个包含 pattern 的行

:100, +5 p                 表示打印 当前行+5 到 100 行之间的内容
:100;+5 p                  打印 100-105 行之间的内容, 使用分号时候第一行地址会被当做当前光标的位置
:/pattern;+10 p            显示包含 pattern 行的后十行内容

:g/pattern                寻找文件中最后一次出现 pattern 的地方, g 表示全局, 可以让搜索模式显示并包含这个模式的所有行
:g/pattern/p              寻找并显示所有包含 pattern 的行
:g!/pattern/nu            寻找并显示不包含 pattern 的行, 并展示对应的行号
:1,10g/pattern            寻找 1-10 行中包含 pattern 的行

:1d | s/This/this         删除第一行, 并在当前行(原来的第二行)中替换 This 为 this
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;ex-的保存于离开文件&quot;&gt;ex 的保存于离开文件&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:w                        将缓冲区内容写入到文件中, 但不离开
:q                        离开编辑器
:wq                       写入并离开,即使文件无任何修改也一样会写入
:x                        写入文件同时离开, 仅当有修改时才会写入
:!                        忽略警告, vi 会保护现有文件, 当需要将缓冲区内容写入到文件中会有警告产生

:w newfile               将缓冲区内容写入到新的文件, 原有的文件不会改变
:1,10w newfile           将缓冲区中 1-10 写入到新的文件
:1,10w &amp;gt;&amp;gt; newfile        将缓冲区 1-10 行内容附加到新文件中

:r newfle                read 可简写为 r, 将新文件内容读出并插入到光标所在位置的下一行
:2r newfile              将新文件内容插入到第 2 行之后
:0r newfile              将新文件内容插入到文件开头
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;vi-多文件编辑&quot;&gt;vi 多文件编辑&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:n                      跳转到下一个文件
:first                  跳转到第一个文件
:last                   跳转到最后一个文件

:e filename             启动一个文件, 存在则打开, 不存在则新建, 可以 tab 补全
:e #                    回到上一个文件, 需要将缓冲区内容写入到文件

:w %.new                写入到当前文件, % 表示当前文件的文件名

ctrl-^                  效果同 :e # 切换到上一个文件

&quot;f6yy -&amp;gt; :w -&amp;gt; :e new.txt -&amp;gt; &quot;fp  ===&amp;gt;  复制光标以及后 6 行内容复制到缓冲区 f 中 -&amp;gt; 缓冲区写入到文件 -&amp;gt; 切换到 new.txt 文件 -&amp;gt; 复制缓冲区 f 中内容到光标后
:1,6ya a  -&amp;gt; :pu a    ===&amp;gt;    拖拽 1-6 行到缓冲区 a  -&amp;gt; 将缓冲区 a 中内容放置到当前光标之后, ya 为拖动命令,pu 为放置命令
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;全局替换&quot;&gt;全局替换&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:s/old/new                     substitute 可缩写为 s, 将当前这一行第一个出现模式 old 的字符串替换为 new, /用来分割各个命令, 最后一个/可省略
:s/old/new/g                   将当前这一行中所有的 old 替换为 new, g表示该行中所有模式, :g 表示文件中每一行
:1,10s/old/new/g               将 1-10 行中所有的 old 替换为 new
:%s/old/new/g                  通 :1,$s/old/new/g , 将整个文件的 old 替换为 new    
:1,10s/old/new/gc              替换 1-10 行中所有的 old, 每一个都需要确认
:g/pattern/s/old/new/g         遇到包含 pattern 的行时候将 old 替换为 new
:g/pattern/s//new/g            遇到包含 pattern 的行将 pattern 替换为 new, 此时直接用 :%s/pattern/new/g 即可
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;搜索模式的元字符&quot;&gt;搜索模式的元字符&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.                    匹配任何单一字符, 包含空格, 除掉换行符
*                    匹配出位于此符号前的单一字符,该字符可以出现 0 到多个
^                    表示后边的正则表达式必须位于行开头
$                    表示正则表达式必须位于行结尾
\                    转义字符, 例如 \. 表示匹配 . 而不是任意字符
[]                   匹配出方括号中任意一个字符, [^a-z] 则表示匹配不是小写字母的字符, [] 中的 ^ 表示取反
\(\)                 将\(\)之间模式匹配到的内容保留到缓冲区, 一般可以保留一行中 9 个模式, 例如 \(That\) or \(this\) 则将 That 保留到缓冲区 1, this 到 2
\&amp;lt;\&amp;gt;                 匹配某些字符开头的单词, 例如 \&amp;lt;ac 只会匹配出以 ac开头的单词, 而 ac\&amp;gt; 只会匹配出以 ac 结尾的单词
~                    匹配任何上一次搜索所使用的正则表达式, 只能用于正则搜索, 即 /

[:alnum:]            字母与数字字符
[:alpha:]            字母字符
[:blank:]            空格与指标符
[:cnctrl:]           控制字符
[:digit:]            数字字符
[:graph:]            可打印的与可见的(不包括空格)字符, 不包括空白
[:print:]            可打印的字符, 包括空白
[:punct:]            标点符号
[:space:]            空白字符
[:upper:]            大写字符
[:xdigit:]           十六进制数字

\n                   利用\(\)存储的第 n 个模式的文字做代换, n 表示数字 1-9, 之前存储的模式是从左到右来计算
\                    将后面一个字符当做普通字符来看到
&amp;amp;                    用在替换字符串中时, 替换为搜索模式匹配出的完整模式, 例如 :%s/AAA/&amp;amp;, bbb 则替换字符串为 AAA, bbb
\u 或 \l             使替换字符串下一个字符变为大写或小写
\U 或 \L 或 \e 或\E   将后边的字符串或直到出现 \e 或 \E 为止, 全部替换为大写或者小写
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;set-命令&quot;&gt;:set 命令&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:set option            打开选项
:set nooption          关闭选项

:set ic                指定搜索模式忽略大小写
:set noic              指定搜索模式区分大小写

:set window=20         设置屏幕窗口显示的行数
:set wrapmargin        设置右边界距离, 用于自动换行

:set all               检查 vi 正在使用的选项
:set option?           查询指定选项的当前值

noignorecase           搜索时区分大小写
wrapscan               回到文件开头继续搜索, 表示在文件中任何一处开始搜索, 都可以找到符合的文本
magic                  模式匹配时候辨识通配符
autoindent             设置自动缩排, ctrl-t 下一层缩进, ctrl-d 上一层缩进
shiftwith=4            设置默认向左或向右为 4 个空格
tabstop                设置 tab 占用 4 个空格
list                   显示控制字符
showmatch              显示对应匹配的括号, 插入模式会有效果
mourse=a               多窗口下, 鼠标跟随
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;exrc-文件-无需--即可-因为读入-exrc-文件的是-ex-读入的&quot;&gt;exrc 文件, 无需 : 即可, 因为读入 exrc 文件的是 ex 读入的&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;主目录下的.exrc 文件中添加 set exrc 则 ex 可以读取当前目录下的.exrc 文件
:so .otherexrc        source 可缩写为 so, 加载其他的 exrc 文件
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;执行-unix-命令&quot;&gt;执行 unix 命令&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:!command             ! 会告诉 ex 创建一个shell, 且后续文本视为 uninx 命令
:!date                显示系统时间
:sh                   创建一个 shell, 可以执行多个 uninx 命令, 结束时按 ctrl-d 回到 vi

:r !command           read 可简写为 r, 可与 uninx 命令结合, 把 uninx命令的结果读入到文件中
:1r !date             将系统时间读入到文件第一行

:1,10 !sort           将 1-10 行排序
!)command             将下一句内容传递给 command
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;单词缩写-插入模式定义宏&quot;&gt;单词缩写, 插入模式定义宏&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ab mb Mobiuspace            设置 Mobiuspace 的缩写为 mb, 在 vi 中输入时会自动展开, 缩写的单词不能出现在所代表的词组的词尾
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;命令缩写-命令模式定义宏&quot;&gt;命令缩写, 命令模式定义宏&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:map x sequence             定义字符 x 映射到编辑命令 sequence
:unmap x                    取消定义给 x 的编辑命令 sequence
:map                        列出所有被映射的字符

:map v dwelp                dw 删除一个单词, e 移到下一个单词结尾, l 向右移动一个空格, p 将删除的单词放置到新位置
:map! - dw                  命令模式下强制覆盖 - 为 dw 命令
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;使用-tag-uninx-有-ctags-命令可以与-vi-的tag命令一起使用&quot;&gt;使用 tag, uninx 有 ctags 命令可以与 vi 的:tag命令一起使用&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:ctags *.c                 创建描述所有 c源代码文件的 tags 文件
:tag name                  在 tags 文件中寻找 name 的定义
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;vim-启动&quot;&gt;vim 启动&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vim -d file1 file2        diff 缩写为 d, 以 diff 模式启动编辑文件
vim -o file1 file2        所有文件均各自打开窗口
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;vim-多窗口编辑&quot;&gt;vim 多窗口编辑&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:split                    水平分割当前窗口
ctrl-w -&amp;gt; s               水平分割当前窗口
:new                      水平分割当前窗口, 会自动适配一些配置

:vsplit                   垂直分割当前窗口

:[n]split [++opt] [cmd] [file]        n 为 vim 指定新窗口显示的行数

ctrl-w -&amp;gt; ctrl-j          移动到下一个窗口
ctrl-w -&amp;gt; ctrl-k          移动到上一个窗口
ctrl-w -&amp;gt; ctrl-h          移动到当前窗口左侧
ctrl-w -&amp;gt; ctrl-l          移动到当前窗口右侧

ctrl-w -&amp;gt; ctrl-p          移动到最后一次访问的窗口
ctrl-w -&amp;gt; ctrl-t          移动到最左上角的窗口
ctrl-w -&amp;gt; ctrl-b          移动到最右下角的窗口

ctrl-w -&amp;gt; +               当前窗口增加一行
:resize +2                当前窗口增加两行
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;vim-缓冲区命令&quot;&gt;vim 缓冲区命令&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:ls                     列出缓冲区文件
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Chaim</name></author><category term="vim" /><category term="cheatsheet" /><summary type="html">命令执行格式 (command) (number) (text object) (number) (command) (text object) 基础操作 ZZ 或 :wq 保存并退出 :e! 恢复到上一次存储的文件内容 :w pathname/filename 写入到其他文件中 :rf pathname/filename 删除其他文件 :!ls pathname 查看其他目录使用情况 :sh -&amp;gt; ctrl-d 或 exit 创建对应的 shell 执行其任务后再返回 ctrl-z -&amp;gt; fg 暂停 vi 后执行对应的任务后再返回 按字符光标移动 h/l 左/右 移动一个字符 4l 向右 4 个字符 按行光标移动 0 移动到行首 $ 移动到行尾 ^ 移到当前行第一个非空格处 10| 移到当前行第 10 列 j/k 上一行/下一行 2j 向上移动 2 行 G 移动到文件的结尾 1G 移动到文件的第一行 ctrk-g 屏幕底部显示信息, 包含行号, 文件总行数, 当前位置占全文的百分比 按照文本块移动 w 移动一个单词, 包含符号与标点 W 移动一个单词, 不包含符号与标点 2w 移动两个单词 b 倒退一个单词, 包含符号与标点 B 倒退一个单词, 不好干符号与标点 e 移到单词的尾部 E 移到单词的尾部, 忽略标点符号 ( 移到当前句子的开头, 标点符号后有两个空格或者一行的最后一个非空格字符时候为一个句子 ) 移到下一个句子的开头 3) 向上移动 3 个句子 { 移到当前这一段的开头, 段落指的是空白行下的文本 } 移到下一段的开头 [[ 移到当前这一节的开头 ]] 移到下一节的开头 简单的文件编辑 i insert, 插入 a add, 添加 c change, 更改 d delete, 删除后放到缓冲区 p paste, 粘贴, d -&amp;gt; p 可以移动行 y 复制 cw 表示更改整个单词 x 删除一个字符 r 重写改写一个字符 添加文本 a 光标之后添加 A 行结尾添加 i 光标之前添加 I 行开头添加 o 光标位置下一行打开新行添加 O 光标位置上一行打开新行添加 修改文本, 需告知有多少文本要修改, 可结合光标移动命令使用 cw 光标到单词结尾要修改, 因此可以用英语单词的部分修改, 只要光标停留在需要修改的开始位置即可 c2b 光标往前 2 个字符 c$ 或 C 光标到本行结尾 c0 光标到此行开头 cc 修改整行文本 替换文本 r 替换一个字符 2r 同时替换两个字符 R 替换整行, 逐渐覆盖 s 替换一个字符, 先删除字符, 并进入插入模式, 因此可以用于将一个字符替换为多个的情况 S 替换整行, 先删除整行, 并进入插入模式 修改大小写 ~ 修改一个字符为大写或者小写 3~ 修改三个字符为大写或者小写 删除文本, 需要告知有多少文本需要删除, 可结合光标移动命令使用 dw 删除光标到单词尾部的字符, 包含单词尾部的空白 de 删除光标到单词本身尾部的字符, 不包含尾部后边的空白 dE 删除光标到单词尾部, 包含标点符号 db 向前删除一个字符 d0 删除光标到行开头的字符 d$ 或 D 删除光标到结尾的字符 dd 删除一整行字符 2dd 删除两行字符 x x-ing out 打印机消除的意思, 删除一个字符 2x 删除两个字符 X 删除光标之前的一个字符 2X 删除光标之前的两个字符 误删恢复 u 撤销上一个命令 3p 将第三个缓冲区放到下一行, 默认保留九个缓冲区 ctrl-r 重做一次撤销操作 移动文本, 采用先删除后放置的方法 p 将缓冲区文本放到光标之后, 单行则放到同一行, 多行缓冲区则另起一行 P 将缓冲区文本放到光标之前 xp 对调两个字符 复制文本, 需要告知有多少文本需要复制, 可结合光标移动命令使用 yw 复制光标到单词尾部的字符 y0 复制光标到行开头的字符 y$ 复制光标到行结尾的字符 yy 或 Y 复制整行内容 重复命令, 每个命令均会被存储到一个临时的缓冲区, 直到发出下一个命令为主 . 重复上一次的命令 合并行 J 合并两行, 将当前行与下一行合并 3J 合并三行 编辑命令 文本对象 更改 删除 复制 单个字符 r x yl 五个字符 5s 5x y5l 一个单词 cw dw yw 两个单词, 不包含标点符号 c2W d2W y2W 后退三个单词 c2b d2b y2b 一整行 cc dd yy 到一行的结尾 c$ 或 C d$ 或 D y$ 到一行的开头 c0 d0 y0 光标移动命令 移动 命令 ←↓↑→ hjkl 下一行第一个字符 + 上一行第一个字符 - 单词结尾 e 或 E 往前一个单词 w 或 W 往后一个单词 b 或 B 到一行的结尾 $ 到一行的开头 0 往缓冲区放置文本 p 或 P 保存编辑结果并离开 ZZ 不保存编辑结果并离开 :q! 光标所在位置插入文本 i 一行开头插入文本 I 光标所在位置附加文本 a 一行最后附加文本 A 光标下一行打开新行 o 光标上一行打开新行 O 删除一行并替换文本 S 新文本覆盖现有文本 R 合并当前行与下一行 J 重复上一个动作 . 撤销上一个动作 u 滚动屏幕 z-enter 移动当前行到屏幕顶端并滚动屏幕 z. 移动当前行到屏幕中心并滚动屏幕 z- 移动当前 ctrl-f forward, 向上滚动一屏 ctrl-b backward, 向下滚动一屏 ctrl-u up, 向上滚动半屏 ctrl-d down, 向下滚动半屏 100z 将第一百行滚动到屏幕顶端 光标在屏幕中移动 H high, 移到屏幕顶端的行 M middle, 移到屏幕中间的行 L low, 移到屏幕底部的行 10H 移到屏幕顶端往下的第十行 10L 移到屏幕底部往上的第十行 根据搜索模式来移动 / 向下匹配搜索 ? 向上匹配搜索 n 往同一个方向重复搜索 N 往相反方向重复搜索 在当前行搜索 fx 光标移到本行出现下一个 x 字符的地方 2fx 搜索本行第二次出现 x 字符的地方 Fx 光标移到本行出现上一个 x 字符的地方 tx 光标移到本行出现下一个 x 字符的地方的前一个字符 Tx 光标移到本行出现上一个 x 字符的地方的后一个字符 ; 重复上一个搜索命令, 方向相同 , 重复下一个搜索命令, 方向相反 '' 回到上一个包含记号的行开头 `` 回到上一个记号或上下文 百花齐放的打开文件 vi +n file 在第 n 行打开文件 vi + file 在最后一行打开文件 vi +/pattern file 在第一个出现 pattern 的地方打开文件 vi -R file 只读模式显示文件 vi -r file 恢复编辑缓冲区 缓冲区使用 # vi 会将最后 9 次的删除操作保存在编号的缓冲区中, 1-9 的缓冲区, 1 表示最后一次的删除 # vi 会将复制的文本放在按字母标识的缓冲区中, a-z 的缓冲区 &quot;1p 恢复最后一次的删除内容, 光标之后插入 &quot;1pu. 逐一将缓冲区内容放置到当前光标之后, u会删除文本, .则重复放置, 不断轮换知道找到所需的文本 &quot;dyy 将当前行复制到缓冲区 d 中, &quot;加上缓冲区名字, 可以用于命名缓冲区 &quot;dP 将缓冲区 d 中内容放置到光标之前 对某一处做标记 mx 将当前位置标记成 x 'x 单引号, 将光标移动到 x 标记所在的第一行 '' 两个单引号, 回到上一个标记或上下文所在行的开头 `x 反引号, 将光标移到以 x 标记的字符位置 `` 两个反引号, 回到上一个标记或上下文的确切位置 vi 缓冲区与标记命令 命令 意义 +n file 在第 n 行打开 file + file 在最后一行打开 file + /pattern file 在第一个出现 pattern 的地方打开 file -c command file 在打开文件后执行命令, 通常是行号或者搜索模式, eg: vi -c /gitlab practice.txt -R 用只读模式打开文件, 与 view 命令相同 -r 死机后恢复文件 1-9 最后 9 次删除操作的内容, 最后一次-最先一次 a-z 可以使用的命名缓冲区, 大写字母表示附加到缓冲区现有内容后 “b command 用缓冲区b 执行命令 mx 将当前位置标记为 x ‘x 将光标移动到标记 x 所在行的第一个字符 ~x 将光标移动到用 x 标记的字符 ’’ 回到上一个标记或上下文所在行的开头 `` 回到上一个标记或上下文的确切位置 ex 命令 :1p 打印第 1 行 :1 打印第 1 行 :1,3 打印 1-3 行 :1s/GitLab/gitlab 替换第一行的 GitLab 为 gitlab :s/GitLab/gitlab 在当前行替换 GitLab 为 gitlab :vi ex 模式下转换为 vi 模式 Q vi 模式下转换为 ex 模式 :1,3d delete 可简写为 d, 删除第 1 行到第 3 行 :1m2 move 可简写为 m, 将第 1 行移到第 2 行之后 :1co2 copy 可简写为 co, 与 t 同意, 将第 1 行复制到第 2 行之后 :set nu number 可简写为 nu, 设置显示行号 :set nonu no number 可简写为 nobu, 禁用显示行号 :1,10# 暂时显示 1-10 行的行号 := 列出文件的总行数 :.= 列出当前所在行的行号 :/pattern/= 列出 patter 第一次出现的行号 :. 表示当前这一行 :$ 表示文件最后一行 :% 表示文件中每一行 :.,+20# 显示当前这一行以及向下 20 行直接的行号 ex 搜索模式 :/pattern/d 删除下一个包含 pattern 的行 :.,/pattern/d 删除当前行以及第一个包含 pattern 的行 :100, +5 p 表示打印 当前行+5 到 100 行之间的内容 :100;+5 p 打印 100-105 行之间的内容, 使用分号时候第一行地址会被当做当前光标的位置 :/pattern;+10 p 显示包含 pattern 行的后十行内容 :g/pattern 寻找文件中最后一次出现 pattern 的地方, g 表示全局, 可以让搜索模式显示并包含这个模式的所有行 :g/pattern/p 寻找并显示所有包含 pattern 的行 :g!/pattern/nu 寻找并显示不包含 pattern 的行, 并展示对应的行号 :1,10g/pattern 寻找 1-10 行中包含 pattern 的行 :1d | s/This/this 删除第一行, 并在当前行(原来的第二行)中替换 This 为 this ex 的保存于离开文件 :w 将缓冲区内容写入到文件中, 但不离开 :q 离开编辑器 :wq 写入并离开,即使文件无任何修改也一样会写入 :x 写入文件同时离开, 仅当有修改时才会写入 :! 忽略警告, vi 会保护现有文件, 当需要将缓冲区内容写入到文件中会有警告产生 :w newfile 将缓冲区内容写入到新的文件, 原有的文件不会改变 :1,10w newfile 将缓冲区中 1-10 写入到新的文件 :1,10w &amp;gt;&amp;gt; newfile 将缓冲区 1-10 行内容附加到新文件中 :r newfle read 可简写为 r, 将新文件内容读出并插入到光标所在位置的下一行 :2r newfile 将新文件内容插入到第 2 行之后 :0r newfile 将新文件内容插入到文件开头 vi 多文件编辑 :n 跳转到下一个文件 :first 跳转到第一个文件 :last 跳转到最后一个文件 :e filename 启动一个文件, 存在则打开, 不存在则新建, 可以 tab 补全 :e # 回到上一个文件, 需要将缓冲区内容写入到文件 :w %.new 写入到当前文件, % 表示当前文件的文件名 ctrl-^ 效果同 :e # 切换到上一个文件 &quot;f6yy -&amp;gt; :w -&amp;gt; :e new.txt -&amp;gt; &quot;fp ===&amp;gt; 复制光标以及后 6 行内容复制到缓冲区 f 中 -&amp;gt; 缓冲区写入到文件 -&amp;gt; 切换到 new.txt 文件 -&amp;gt; 复制缓冲区 f 中内容到光标后 :1,6ya a -&amp;gt; :pu a ===&amp;gt; 拖拽 1-6 行到缓冲区 a -&amp;gt; 将缓冲区 a 中内容放置到当前光标之后, ya 为拖动命令,pu 为放置命令 全局替换 :s/old/new substitute 可缩写为 s, 将当前这一行第一个出现模式 old 的字符串替换为 new, /用来分割各个命令, 最后一个/可省略 :s/old/new/g 将当前这一行中所有的 old 替换为 new, g表示该行中所有模式, :g 表示文件中每一行 :1,10s/old/new/g 将 1-10 行中所有的 old 替换为 new :%s/old/new/g 通 :1,$s/old/new/g , 将整个文件的 old 替换为 new :1,10s/old/new/gc 替换 1-10 行中所有的 old, 每一个都需要确认 :g/pattern/s/old/new/g 遇到包含 pattern 的行时候将 old 替换为 new :g/pattern/s//new/g 遇到包含 pattern 的行将 pattern 替换为 new, 此时直接用 :%s/pattern/new/g 即可 搜索模式的元字符 . 匹配任何单一字符, 包含空格, 除掉换行符 * 匹配出位于此符号前的单一字符,该字符可以出现 0 到多个 ^ 表示后边的正则表达式必须位于行开头 $ 表示正则表达式必须位于行结尾 \ 转义字符, 例如 \. 表示匹配 . 而不是任意字符 [] 匹配出方括号中任意一个字符, [^a-z] 则表示匹配不是小写字母的字符, [] 中的 ^ 表示取反 \(\) 将\(\)之间模式匹配到的内容保留到缓冲区, 一般可以保留一行中 9 个模式, 例如 \(That\) or \(this\) 则将 That 保留到缓冲区 1, this 到 2 \&amp;lt;\&amp;gt; 匹配某些字符开头的单词, 例如 \&amp;lt;ac 只会匹配出以 ac开头的单词, 而 ac\&amp;gt; 只会匹配出以 ac 结尾的单词 ~ 匹配任何上一次搜索所使用的正则表达式, 只能用于正则搜索, 即 / [:alnum:] 字母与数字字符 [:alpha:] 字母字符 [:blank:] 空格与指标符 [:cnctrl:] 控制字符 [:digit:] 数字字符 [:graph:] 可打印的与可见的(不包括空格)字符, 不包括空白 [:print:] 可打印的字符, 包括空白 [:punct:] 标点符号 [:space:] 空白字符 [:upper:] 大写字符 [:xdigit:] 十六进制数字 \n 利用\(\)存储的第 n 个模式的文字做代换, n 表示数字 1-9, 之前存储的模式是从左到右来计算 \ 将后面一个字符当做普通字符来看到 &amp;amp; 用在替换字符串中时, 替换为搜索模式匹配出的完整模式, 例如 :%s/AAA/&amp;amp;, bbb 则替换字符串为 AAA, bbb \u 或 \l 使替换字符串下一个字符变为大写或小写 \U 或 \L 或 \e 或\E 将后边的字符串或直到出现 \e 或 \E 为止, 全部替换为大写或者小写 :set 命令 :set option 打开选项 :set nooption 关闭选项 :set ic 指定搜索模式忽略大小写 :set noic 指定搜索模式区分大小写 :set window=20 设置屏幕窗口显示的行数 :set wrapmargin 设置右边界距离, 用于自动换行 :set all 检查 vi 正在使用的选项 :set option? 查询指定选项的当前值 noignorecase 搜索时区分大小写 wrapscan 回到文件开头继续搜索, 表示在文件中任何一处开始搜索, 都可以找到符合的文本 magic 模式匹配时候辨识通配符 autoindent 设置自动缩排, ctrl-t 下一层缩进, ctrl-d 上一层缩进 shiftwith=4 设置默认向左或向右为 4 个空格 tabstop 设置 tab 占用 4 个空格 list 显示控制字符 showmatch 显示对应匹配的括号, 插入模式会有效果 mourse=a 多窗口下, 鼠标跟随 exrc 文件, 无需 : 即可, 因为读入 exrc 文件的是 ex 读入的 主目录下的.exrc 文件中添加 set exrc 则 ex 可以读取当前目录下的.exrc 文件 :so .otherexrc source 可缩写为 so, 加载其他的 exrc 文件 执行 unix 命令 :!command ! 会告诉 ex 创建一个shell, 且后续文本视为 uninx 命令 :!date 显示系统时间 :sh 创建一个 shell, 可以执行多个 uninx 命令, 结束时按 ctrl-d 回到 vi :r !command read 可简写为 r, 可与 uninx 命令结合, 把 uninx命令的结果读入到文件中 :1r !date 将系统时间读入到文件第一行 :1,10 !sort 将 1-10 行排序 !)command 将下一句内容传递给 command 单词缩写, 插入模式定义宏 ab mb Mobiuspace 设置 Mobiuspace 的缩写为 mb, 在 vi 中输入时会自动展开, 缩写的单词不能出现在所代表的词组的词尾 命令缩写, 命令模式定义宏 :map x sequence 定义字符 x 映射到编辑命令 sequence :unmap x 取消定义给 x 的编辑命令 sequence :map 列出所有被映射的字符 :map v dwelp dw 删除一个单词, e 移到下一个单词结尾, l 向右移动一个空格, p 将删除的单词放置到新位置 :map! - dw 命令模式下强制覆盖 - 为 dw 命令 使用 tag, uninx 有 ctags 命令可以与 vi 的:tag命令一起使用 :ctags *.c 创建描述所有 c源代码文件的 tags 文件 :tag name 在 tags 文件中寻找 name 的定义 vim 启动 vim -d file1 file2 diff 缩写为 d, 以 diff 模式启动编辑文件 vim -o file1 file2 所有文件均各自打开窗口 vim 多窗口编辑 :split 水平分割当前窗口 ctrl-w -&amp;gt; s 水平分割当前窗口 :new 水平分割当前窗口, 会自动适配一些配置 :vsplit 垂直分割当前窗口 :[n]split [++opt] [cmd] [file] n 为 vim 指定新窗口显示的行数 ctrl-w -&amp;gt; ctrl-j 移动到下一个窗口 ctrl-w -&amp;gt; ctrl-k 移动到上一个窗口 ctrl-w -&amp;gt; ctrl-h 移动到当前窗口左侧 ctrl-w -&amp;gt; ctrl-l 移动到当前窗口右侧 ctrl-w -&amp;gt; ctrl-p 移动到最后一次访问的窗口 ctrl-w -&amp;gt; ctrl-t 移动到最左上角的窗口 ctrl-w -&amp;gt; ctrl-b 移动到最右下角的窗口 ctrl-w -&amp;gt; + 当前窗口增加一行 :resize +2 当前窗口增加两行 vim 缓冲区命令 :ls 列出缓冲区文件</summary></entry><entry><title type="html">Redis内存模型</title><link href="http://localhost:4000/2020/08/07/Redis%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html" rel="alternate" type="text/html" title="Redis内存模型" /><published>2020-08-07T00:00:00+08:00</published><updated>2020-08-07T00:00:00+08:00</updated><id>http://localhost:4000/2020/08/07/Redis%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B</id><content type="html" xml:base="http://localhost:4000/2020/08/07/Redis%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html">&lt;h1 id=&quot;内存使用统计&quot;&gt;内存使用统计&lt;/h1&gt;

&lt;h2 id=&quot;info-中常见属性说明&quot;&gt;info 中常见属性说明&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;属性名&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;属性说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;used_memory&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Redis 分配器分配的内存总量(单位字节), 包含 swap&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;used_memory_human&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;以可读方式返回 used_memory&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;used_memory_rss&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Redis 进程占操作系统的内存总量(单位字节),  跟top 或 ps 看到的一致&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;used_memory_peak&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;内存使用的最大值, 即 used_memory 的峰值&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;used_memory_peak_human&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;以可读方式返回used_memory_peak&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;used_memory_lua&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Lua 引擎所消耗的内存大小&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;mem_fragmentation_ratio&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;used_memory_rss / used_memory 比值, 表示内存碎片率&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;mem_allocator&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Redis 所使用的内存分配器, 默认为 jemalloc&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;属性说明补充&quot;&gt;属性说明补充&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;used_memory 是 redis 使用的实际使用的内存总量, 因此被内存碎片浪费掉的内存不包含在内&lt;/li&gt;
  &lt;li&gt;mem_fragmentation_ratio一般大于 1, 业界内认为一般在 1.03 左右是健康水平.&lt;/li&gt;
  &lt;li&gt;mem_fragmentation_ratio 的值越大, 内存碎片的比例越大&lt;/li&gt;
  &lt;li&gt;mem_fragmentation_ratio &amp;lt; 1 时候, 一般是使用了 swap 导致的&lt;/li&gt;
  &lt;li&gt;当 redis 无数据时候或数据很少时候, used_memory_rss 比 used_memory 大很多, 碎片率暂无参考价值&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;内存消耗划分&quot;&gt;内存消耗划分&lt;/h1&gt;

&lt;h2 id=&quot;实际占用内存组成&quot;&gt;实际占用内存组成&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;redis 自身进程内存&lt;/li&gt;
  &lt;li&gt;对象内存&lt;/li&gt;
  &lt;li&gt;缓冲内存&lt;/li&gt;
  &lt;li&gt;内存碎片&lt;/li&gt;
  &lt;li&gt;子进程内存消耗&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;redis-自身进程内存&quot;&gt;redis 自身进程内存&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;空 redis 进程自身消耗的内存
    &lt;ol&gt;
      &lt;li&gt;docker 容器版本, used_memory_rss一般为 9MB 左右&lt;/li&gt;
      &lt;li&gt;进程版本, used_memory_rss 一般为为3MB 左右&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;故, Redis 自身进程内存可以忽略不计&lt;/li&gt;
  &lt;li&gt;由于不是 jemalloc 分配的内存, 因此不会统计在 used_memory 中&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;## 对象内存&lt;/p&gt;

&lt;p&gt;用户数据再 redis 内占用的内存&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;由于是 k-v 结构, 故每个键值对的内存消耗为: sizeof(k) + sizeof(v)&lt;/li&gt;
  &lt;li&gt;键为字符串, 建议避免使用过长的键&lt;/li&gt;
  &lt;li&gt;值为字符串, 列表, 哈希, 集合, 有序集合这五种, 其中 Bitmaps 和 HyperLog 使用字符串实现, GEO 使用有序集合实现&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;缓冲内存&quot;&gt;缓冲内存&lt;/h2&gt;

&lt;p&gt;主要包含: &lt;strong&gt;客户端缓冲&lt;/strong&gt;, &lt;strong&gt;复制积压缓冲区&lt;/strong&gt;,  &lt;strong&gt;AOF 缓冲区&lt;/strong&gt;. 该部分内存由 jemalloc 分配, 因此会包含在 used_memory 中&lt;/p&gt;

&lt;h3 id=&quot;客户端缓冲&quot;&gt;客户端缓冲&lt;/h3&gt;

&lt;p&gt;主要包含普通客户端, 从客户端, 订阅客户端. 所有接入到 Redis 服务器 TCP 连接的输入输出缓冲, 因此有时候也被称为输入输出缓冲区&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;输入缓冲无法控制, 最大为 1G&lt;/li&gt;
  &lt;li&gt;输出缓冲通过参数 client-output-buffer-limit 控制, 默认值如下&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;client-output-buffer-limit normal 0 0 0
client-output-buffer-limit replica 256mb 64mb 60
client-output-buffer-limit pubsub 32mb 8mb 60
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;普通客户端主要指除了复制和订阅的客户端之外的所有连接. 默认未做限制, 因为普通客户端的内存消耗可以忽略不计. 但是当有大量慢连接客户端时候, 消耗就很大, 例如客户端执行 monitor 之类的需要输出大量数据时候, 很容易造成 redis 服务器的内存突然飙升. 一般会调整 maxclients 来限制&lt;/li&gt;
  &lt;li&gt;从客户端主要用于主从复制, 主节点会单独建立一条连接用于命令复制. 当主从延迟很高或者挂载过多的从节点时候, 会导致该部分占用很大. 因此推荐主从不跨异地, 从节点不多于 2 个&lt;/li&gt;
  &lt;li&gt;订阅客户端主要用于发布订阅功能, 该功能会使用单独的输出缓冲区. 当生产消息快于消费速度时候, 输出缓冲区的积压会造成缓冲区空间的益处.&lt;/li&gt;
  &lt;li&gt;输入输出缓冲区在大流量的情况下, 容易失控, 推荐做一定的监控.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;复制积压缓冲区&quot;&gt;复制积压缓冲区&lt;/h3&gt;

&lt;p&gt;该缓冲区是在 2.8 版本以后提供的恶一个可重用的固定大小的缓冲区, 用于实现部分复制功能, 默认值如下:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;repl-backlog-size 1mb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;所用的从节点会共用才缓冲区, 因此可以适当调大, 一般会推荐 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;100MB&lt;/code&gt;的样子, 可以避免全量复制的情况&lt;/p&gt;

&lt;h3 id=&quot;aof-缓冲区&quot;&gt;AOF 缓冲区&lt;/h3&gt;

&lt;p&gt;该部分空间用于 redis 重写期间, 保存最近写入的命令. 该部分无法控制, 消耗的内存取决于 AOF 重写时间和写入的命令量, 大部分情况下占用都很小.&lt;/p&gt;

&lt;h2 id=&quot;内存碎片&quot;&gt;内存碎片&lt;/h2&gt;

&lt;p&gt;默认采用的是 jemalloc 的分配器, 编译时可选 glibc, tcmalloc 的分配器. jemalloc 一般讲系统内存划分为小, 大, 巨大三个范围. 每个范围又划分更多更小的内存单位, 如下所示:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;小   [8byte] [16byte] [32byte] [64byte] ...
大   [4KB] [8KB] [12KB] [16KB] ...
巨大 [4MB] [8MB] [12MB] [16MB] ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当需要保存 5KB 的对象时候, jemalloc 可能会采用 8KB 的块存储, 而剩下的 3KB 空间就变为内存碎片不能再分配给其他对象存储, 由此产生了内存碎片. &lt;strong&gt;此时的 5KB 被纳入到 used_memory 的统计范围内, 操作系统上表现为 redis 消耗了 8KB 的内存.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;高碎片率的原因&quot;&gt;高碎片率的原因&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;针对已存在的 key 频繁执行更新操作&lt;/li&gt;
  &lt;li&gt;大量过期键删除, 释放的空间未能得到使用&lt;/li&gt;
  &lt;li&gt;存储的数据长短差异较大&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;高碎片率解决版本&quot;&gt;高碎片率解决版本&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;数据对齐, 尽量使用数字类型或者固定长度的字符串&lt;/li&gt;
  &lt;li&gt;安全重启, 主从切换安全重启&lt;/li&gt;
  &lt;li&gt;redis4 以上设置 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;config set activedefrag yes&lt;/code&gt; 来保证自动清理&lt;/li&gt;
  &lt;li&gt;redis4 以上可以手动执行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;memory purge&lt;/code&gt; 来清理内存碎片&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;子进程内存消耗&quot;&gt;子进程内存消耗&lt;/h2&gt;

&lt;p&gt;子进程内存消耗多指的是 AOF/RDB 过程创建的子进程所带来的内存消耗. 由于 linux 存在 copy-on-write 的机制, 因此父子进程会共享相同的物理内存页, 因而不需要 2 倍的物理内存来完成重写.&lt;/p&gt;

&lt;h1 id=&quot;内存管理&quot;&gt;内存管理&lt;/h1&gt;

&lt;p&gt;redis 中使用 maxmemory 的参数控制最大可用内存. 主要目的如下:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;当内存超出 maxmemory 时候, 可以使用 LRU 等策略释放空间&lt;/li&gt;
  &lt;li&gt;避免超过服务器物理内存&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;前方雷点请注意&quot;&gt;前方雷点请注意&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;maxmemory 控制的是 redis 实际使用的内存量, 也就是 used_memory 统计项对应的内存&lt;/li&gt;
  &lt;li&gt;由于被浪费的内存未被纳入到 used_memory 的统计内, 因此实际消耗的内存会比 maxmemory 设置的还要大, 真实消耗的内存可粗略估计为&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;maxmemory * mem_fragmentation_ratio
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Chaim</name></author><category term="redis" /><category term="memory" /><summary type="html">内存使用统计 info 中常见属性说明 属性名 属性说明 used_memory Redis 分配器分配的内存总量(单位字节), 包含 swap used_memory_human 以可读方式返回 used_memory used_memory_rss Redis 进程占操作系统的内存总量(单位字节), 跟top 或 ps 看到的一致 used_memory_peak 内存使用的最大值, 即 used_memory 的峰值 used_memory_peak_human 以可读方式返回used_memory_peak used_memory_lua Lua 引擎所消耗的内存大小 mem_fragmentation_ratio used_memory_rss / used_memory 比值, 表示内存碎片率 mem_allocator Redis 所使用的内存分配器, 默认为 jemalloc 属性说明补充 used_memory 是 redis 使用的实际使用的内存总量, 因此被内存碎片浪费掉的内存不包含在内 mem_fragmentation_ratio一般大于 1, 业界内认为一般在 1.03 左右是健康水平. mem_fragmentation_ratio 的值越大, 内存碎片的比例越大 mem_fragmentation_ratio &amp;lt; 1 时候, 一般是使用了 swap 导致的 当 redis 无数据时候或数据很少时候, used_memory_rss 比 used_memory 大很多, 碎片率暂无参考价值 内存消耗划分 实际占用内存组成 redis 自身进程内存 对象内存 缓冲内存 内存碎片 子进程内存消耗 redis 自身进程内存 空 redis 进程自身消耗的内存 docker 容器版本, used_memory_rss一般为 9MB 左右 进程版本, used_memory_rss 一般为为3MB 左右 故, Redis 自身进程内存可以忽略不计 由于不是 jemalloc 分配的内存, 因此不会统计在 used_memory 中 ## 对象内存 用户数据再 redis 内占用的内存 由于是 k-v 结构, 故每个键值对的内存消耗为: sizeof(k) + sizeof(v) 键为字符串, 建议避免使用过长的键 值为字符串, 列表, 哈希, 集合, 有序集合这五种, 其中 Bitmaps 和 HyperLog 使用字符串实现, GEO 使用有序集合实现 缓冲内存 主要包含: 客户端缓冲, 复制积压缓冲区, AOF 缓冲区. 该部分内存由 jemalloc 分配, 因此会包含在 used_memory 中 客户端缓冲 主要包含普通客户端, 从客户端, 订阅客户端. 所有接入到 Redis 服务器 TCP 连接的输入输出缓冲, 因此有时候也被称为输入输出缓冲区 输入缓冲无法控制, 最大为 1G 输出缓冲通过参数 client-output-buffer-limit 控制, 默认值如下 client-output-buffer-limit normal 0 0 0 client-output-buffer-limit replica 256mb 64mb 60 client-output-buffer-limit pubsub 32mb 8mb 60 普通客户端主要指除了复制和订阅的客户端之外的所有连接. 默认未做限制, 因为普通客户端的内存消耗可以忽略不计. 但是当有大量慢连接客户端时候, 消耗就很大, 例如客户端执行 monitor 之类的需要输出大量数据时候, 很容易造成 redis 服务器的内存突然飙升. 一般会调整 maxclients 来限制 从客户端主要用于主从复制, 主节点会单独建立一条连接用于命令复制. 当主从延迟很高或者挂载过多的从节点时候, 会导致该部分占用很大. 因此推荐主从不跨异地, 从节点不多于 2 个 订阅客户端主要用于发布订阅功能, 该功能会使用单独的输出缓冲区. 当生产消息快于消费速度时候, 输出缓冲区的积压会造成缓冲区空间的益处. 输入输出缓冲区在大流量的情况下, 容易失控, 推荐做一定的监控. 复制积压缓冲区 该缓冲区是在 2.8 版本以后提供的恶一个可重用的固定大小的缓冲区, 用于实现部分复制功能, 默认值如下: repl-backlog-size 1mb 所用的从节点会共用才缓冲区, 因此可以适当调大, 一般会推荐 100MB的样子, 可以避免全量复制的情况 AOF 缓冲区 该部分空间用于 redis 重写期间, 保存最近写入的命令. 该部分无法控制, 消耗的内存取决于 AOF 重写时间和写入的命令量, 大部分情况下占用都很小. 内存碎片 默认采用的是 jemalloc 的分配器, 编译时可选 glibc, tcmalloc 的分配器. jemalloc 一般讲系统内存划分为小, 大, 巨大三个范围. 每个范围又划分更多更小的内存单位, 如下所示: 小 [8byte] [16byte] [32byte] [64byte] ... 大 [4KB] [8KB] [12KB] [16KB] ... 巨大 [4MB] [8MB] [12MB] [16MB] ... 当需要保存 5KB 的对象时候, jemalloc 可能会采用 8KB 的块存储, 而剩下的 3KB 空间就变为内存碎片不能再分配给其他对象存储, 由此产生了内存碎片. 此时的 5KB 被纳入到 used_memory 的统计范围内, 操作系统上表现为 redis 消耗了 8KB 的内存. 高碎片率的原因 针对已存在的 key 频繁执行更新操作 大量过期键删除, 释放的空间未能得到使用 存储的数据长短差异较大 高碎片率解决版本 数据对齐, 尽量使用数字类型或者固定长度的字符串 安全重启, 主从切换安全重启 redis4 以上设置 config set activedefrag yes 来保证自动清理 redis4 以上可以手动执行memory purge 来清理内存碎片 子进程内存消耗 子进程内存消耗多指的是 AOF/RDB 过程创建的子进程所带来的内存消耗. 由于 linux 存在 copy-on-write 的机制, 因此父子进程会共享相同的物理内存页, 因而不需要 2 倍的物理内存来完成重写. 内存管理 redis 中使用 maxmemory 的参数控制最大可用内存. 主要目的如下: 当内存超出 maxmemory 时候, 可以使用 LRU 等策略释放空间 避免超过服务器物理内存 前方雷点请注意 maxmemory 控制的是 redis 实际使用的内存量, 也就是 used_memory 统计项对应的内存 由于被浪费的内存未被纳入到 used_memory 的统计内, 因此实际消耗的内存会比 maxmemory 设置的还要大, 真实消耗的内存可粗略估计为 maxmemory * mem_fragmentation_ratio</summary></entry><entry><title type="html">AWS 本地采用 ECR 镜像进行调试</title><link href="http://localhost:4000/2020/08/04/%E6%9C%AC%E5%9C%B0%E9%87%87%E7%94%A8-ECR-%E9%95%9C%E5%83%8F%E8%BF%9B%E8%A1%8C%E8%B0%83%E8%AF%95.html" rel="alternate" type="text/html" title="AWS 本地采用 ECR 镜像进行调试" /><published>2020-08-04T00:00:00+08:00</published><updated>2020-08-04T00:00:00+08:00</updated><id>http://localhost:4000/2020/08/04/%E6%9C%AC%E5%9C%B0%E9%87%87%E7%94%A8%20ECR%20%E9%95%9C%E5%83%8F%E8%BF%9B%E8%A1%8C%E8%B0%83%E8%AF%95</id><content type="html" xml:base="http://localhost:4000/2020/08/04/%E6%9C%AC%E5%9C%B0%E9%87%87%E7%94%A8-ECR-%E9%95%9C%E5%83%8F%E8%BF%9B%E8%A1%8C%E8%B0%83%E8%AF%95.html">&lt;h1 id=&quot;前置条件&quot;&gt;前置条件&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;具备 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aws cli&lt;/code&gt;权限&lt;/li&gt;
  &lt;li&gt;本地配置 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker&lt;/code&gt;环境&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;操作步骤&quot;&gt;操作步骤&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;查看 ci 过程，获取镜像地址，例如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;image xxx.dkr.ecr.us-east-1.amazonaws.com/ci-base/java8/v1&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;获取 ecr 授权密码，cmd 中输入 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aws ecr get-login-password&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;本地 docker 授权 ecr，cmd 中输入 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker login -u AWS xxx.dkr.ecr.us-east-1.amazonaws.com&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Chaim</name></author><category term="aws" /><category term="ecr" /><category term="docker" /><summary type="html">前置条件 具备 aws cli权限 本地配置 docker环境 操作步骤 查看 ci 过程，获取镜像地址，例如 image xxx.dkr.ecr.us-east-1.amazonaws.com/ci-base/java8/v1 获取 ecr 授权密码，cmd 中输入 aws ecr get-login-password 本地 docker 授权 ecr，cmd 中输入 docker login -u AWS xxx.dkr.ecr.us-east-1.amazonaws.com</summary></entry></feed>